//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.4.1-SNAPSHOT
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:\Users\Sonic\Documents\Visual Studio 2013\Projects\Glossa\Glossa\GLOSSA.g4 by ANTLR 4.4.1-SNAPSHOT

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591

namespace Glossa {
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.4.1-SNAPSHOT")]
[System.CLSCompliant(false)]
public partial class GLOSSAParser : Parser {
	public const int
		T__0=1, PROGRAMMA=2, ARXH=3, TELOS_PROGRAMMATOS=4, SYNARTHSH=5, TELOS_SYNARTHSHS=6, 
		DIADIKASIA=7, TELOS_DIADIKASIAS=8, METABLHTES=9, STATHERES=10, AN=11, 
		TOTE=12, TELOS_AN=13, ALLIOS_AN=14, ALLIOS=15, ARXH_EPANALIPSIS=16, MEXRIS_OTOU=17, 
		OSO=18, EPANALABE=19, TELOS_EPANALIPSIS=20, GIA=21, APO=22, MEXRI=23, 
		ME_BHMA=24, EPILEKSE=25, PERIPTOSI=26, TELOS_EPILOGON=27, AKERAIES=28, 
		PRAGMATIKES=29, XARAKTHRES=30, LOGIKES=31, GRAPSE=32, EKTIPOSE=33, DIABASE=34, 
		KALESE=35, TRUE=36, FALSE=37, KAI=38, H=39, OXI=40, INTEGER=41, DECIMAL=42, 
		STRING=43, IDENTIFIER=44, EQUALS=45, NOTEQUALS=46, GT=47, GE=48, LT=49, 
		LE=50, PLUS=51, MINUS=52, MUL=53, DIV=54, POWER=55, SEMICOLON=56, COMMA=57, 
		ASSIGNMENT=58, LPAREN=59, RPAREN=60, LBRACKET=61, RBRACKET=62, LANCHOR=63, 
		RANCHOR=64, COMMENTS=65, WS=66;
	public const int
		RULE_file = 0, RULE_program = 1, RULE_statementlist = 2, RULE_statement = 3, 
		RULE_declarations = 4, RULE_functiondefinition = 5, RULE_proceduredefinition = 6, 
		RULE_variabledeclarations = 7, RULE_constantdeclarations = 8, RULE_ifcontrol = 9, 
		RULE_elseif = 10, RULE_else = 11, RULE_dowhileloop = 12, RULE_whileloop = 13, 
		RULE_forloop = 14, RULE_switchcontrol = 15, RULE_casescontrol = 16, RULE_otherwisecontrol = 17, 
		RULE_functionarguments = 18, RULE_assignment = 19, RULE_expressionprimitives = 20, 
		RULE_expression = 21, RULE_type = 22, RULE_keyword = 23, RULE_bool = 24;
	public static readonly string[] ruleNames = {
		"file", "program", "statementlist", "statement", "declarations", "functiondefinition", 
		"proceduredefinition", "variabledeclarations", "constantdeclarations", 
		"ifcontrol", "elseif", "else", "dowhileloop", "whileloop", "forloop", 
		"switchcontrol", "casescontrol", "otherwisecontrol", "functionarguments", 
		"assignment", "expressionprimitives", "expression", "type", "keyword", 
		"bool"
	};

	private static readonly string[] _LiteralNames = {
		null, "':'", "'пяоцяалла'", "'аявг'", "'текос_пяоцяаллатос'", "'сумаятгсг'", 
		"'текос_сумаятгсгс'", "'диадийасиа'", "'текос_диадийасиас'", "'летабкгтес'", 
		"'стахеяес'", "'ам'", "'тоте'", "'текос_ам'", "'аккиыс_ам'", "'аккиыс'", 
		"'аявг_епамакгьгс'", "'левяис_отоу'", "'осо'", "'епамакабе'", "'текос_епамакгьгс'", 
		"'циа'", "'апо'", "'левяи'", "'ле_бгла'", "'епикене'", "'пеяиптысг'", 
		"'текос_епикоцым'", "'айеяаиес'", "'пяацлатийес'", "'ваяайтгяес'", "'коцийес'", 
		"'цяаье'", "'ейтупысе'", "'диабасе'", "'йакесе'", "'акгхгс'", "'ьеудгс'", 
		"'йаи'", "'г'", "'ови'", null, null, null, null, "'='", "'<>'", "'>'", 
		"'>='", "'<'", "'<='", "'+'", "'-'", "'*'", "'/'", "'^'", "';'", "','", 
		"'<-'", "'('", "')'", "'['", "']'", "'{'", "'}'"
	};
	private static readonly string[] _SymbolicNames = {
		null, null, "PROGRAMMA", "ARXH", "TELOS_PROGRAMMATOS", "SYNARTHSH", "TELOS_SYNARTHSHS", 
		"DIADIKASIA", "TELOS_DIADIKASIAS", "METABLHTES", "STATHERES", "AN", "TOTE", 
		"TELOS_AN", "ALLIOS_AN", "ALLIOS", "ARXH_EPANALIPSIS", "MEXRIS_OTOU", 
		"OSO", "EPANALABE", "TELOS_EPANALIPSIS", "GIA", "APO", "MEXRI", "ME_BHMA", 
		"EPILEKSE", "PERIPTOSI", "TELOS_EPILOGON", "AKERAIES", "PRAGMATIKES", 
		"XARAKTHRES", "LOGIKES", "GRAPSE", "EKTIPOSE", "DIABASE", "KALESE", "TRUE", 
		"FALSE", "KAI", "H", "OXI", "INTEGER", "DECIMAL", "STRING", "IDENTIFIER", 
		"EQUALS", "NOTEQUALS", "GT", "GE", "LT", "LE", "PLUS", "MINUS", "MUL", 
		"DIV", "POWER", "SEMICOLON", "COMMA", "ASSIGNMENT", "LPAREN", "RPAREN", 
		"LBRACKET", "RBRACKET", "LANCHOR", "RANCHOR", "COMMENTS", "WS"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[System.Obsolete("Use Vocabulary instead.")]
	public static readonly string[] tokenNames = GenerateTokenNames(DefaultVocabulary, _SymbolicNames.Length);

	private static string[] GenerateTokenNames(IVocabulary vocabulary, int length) {
		string[] tokenNames = new string[length];
		for (int i = 0; i < tokenNames.Length; i++) {
			tokenNames[i] = vocabulary.GetLiteralName(i);
			if (tokenNames[i] == null) {
				tokenNames[i] = vocabulary.GetSymbolicName(i);
			}

			if (tokenNames[i] == null) {
				tokenNames[i] = "<INVALID>";
			}
		}

		return tokenNames;
	}

	[System.Obsolete]
	public override string[] TokenNames
	{
		get
		{
			return tokenNames;
		}
	}

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "GLOSSA.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public GLOSSAParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class FileContext : ParserRuleContext {
		public FileContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_file; } }
	 
		public FileContext() { }
		public virtual void CopyFrom(FileContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class FilestartContext : FileContext {
		public IReadOnlyList<FunctiondefinitionContext> functiondefinition() {
			return GetRuleContexts<FunctiondefinitionContext>();
		}
		public ProgramContext program() {
			return GetRuleContext<ProgramContext>(0);
		}
		public FunctiondefinitionContext functiondefinition(int i) {
			return GetRuleContext<FunctiondefinitionContext>(i);
		}
		public IReadOnlyList<ProceduredefinitionContext> proceduredefinition() {
			return GetRuleContexts<ProceduredefinitionContext>();
		}
		public ProceduredefinitionContext proceduredefinition(int i) {
			return GetRuleContext<ProceduredefinitionContext>(i);
		}
		public FilestartContext(FileContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterFilestart(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitFilestart(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFilestart(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FileContext file() {
		FileContext _localctx = new FileContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_file);
		int _la;
		try {
			_localctx = new FilestartContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 50; program();
			State = 55;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==SYNARTHSH || _la==DIADIKASIA) {
				{
				State = 53;
				switch (_input.La(1)) {
				case SYNARTHSH:
					{
					State = 51; functiondefinition();
					}
					break;
				case DIADIKASIA:
					{
					State = 52; proceduredefinition();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 57;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProgramContext : ParserRuleContext {
		public ProgramContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_program; } }
	 
		public ProgramContext() { }
		public virtual void CopyFrom(ProgramContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ProgramstartContext : ProgramContext {
		public DeclarationsContext declarations(int i) {
			return GetRuleContext<DeclarationsContext>(i);
		}
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public ITerminalNode TELOS_PROGRAMMATOS() { return GetToken(GLOSSAParser.TELOS_PROGRAMMATOS, 0); }
		public IReadOnlyList<DeclarationsContext> declarations() {
			return GetRuleContexts<DeclarationsContext>();
		}
		public ITerminalNode ARXH() { return GetToken(GLOSSAParser.ARXH, 0); }
		public ITerminalNode PROGRAMMA() { return GetToken(GLOSSAParser.PROGRAMMA, 0); }
		public ITerminalNode IDENTIFIER() { return GetToken(GLOSSAParser.IDENTIFIER, 0); }
		public ProgramstartContext(ProgramContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterProgramstart(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitProgramstart(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProgramstart(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ProgramContext program() {
		ProgramContext _localctx = new ProgramContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_program);
		int _la;
		try {
			_localctx = new ProgramstartContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 58; Match(PROGRAMMA);
			State = 59; Match(IDENTIFIER);
			State = 63;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==METABLHTES || _la==STATHERES) {
				{
				{
				State = 60; declarations();
				}
				}
				State = 65;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 66; Match(ARXH);
			State = 67; statementlist();
			State = 68; Match(TELOS_PROGRAMMATOS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementlistContext : ParserRuleContext {
		public StatementlistContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statementlist; } }
	 
		public StatementlistContext() { }
		public virtual void CopyFrom(StatementlistContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class StmtlistContext : StatementlistContext {
		public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public IReadOnlyList<StatementContext> statement() {
			return GetRuleContexts<StatementContext>();
		}
		public StmtlistContext(StatementlistContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterStmtlist(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitStmtlist(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStmtlist(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementlistContext statementlist() {
		StatementlistContext _localctx = new StatementlistContext(_ctx, State);
		EnterRule(_localctx, 4, RULE_statementlist);
		int _la;
		try {
			_localctx = new StmtlistContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 73;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AN) | (1L << ARXH_EPANALIPSIS) | (1L << OSO) | (1L << EPILEKSE) | (1L << GRAPSE) | (1L << EKTIPOSE) | (1L << DIABASE) | (1L << KALESE) | (1L << OXI) | (1L << INTEGER) | (1L << DECIMAL) | (1L << STRING) | (1L << IDENTIFIER) | (1L << PLUS) | (1L << MINUS) | (1L << LPAREN))) != 0)) {
				{
				{
				State = 70; statement();
				}
				}
				State = 75;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
	 
		public StatementContext() { }
		public virtual void CopyFrom(StatementContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Stat_ifctrlContext : StatementContext {
		public IfcontrolContext ifcontrol() {
			return GetRuleContext<IfcontrolContext>(0);
		}
		public Stat_ifctrlContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterStat_ifctrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitStat_ifctrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStat_ifctrl(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Stat_dowhileContext : StatementContext {
		public DowhileloopContext dowhileloop() {
			return GetRuleContext<DowhileloopContext>(0);
		}
		public Stat_dowhileContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterStat_dowhile(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitStat_dowhile(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStat_dowhile(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Stat_ioexprContext : StatementContext {
		public IReadOnlyList<ITerminalNode> COMMA() { return GetTokens(GLOSSAParser.COMMA); }
		public KeywordContext keyword() {
			return GetRuleContext<KeywordContext>(0);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode COMMA(int i) {
			return GetToken(GLOSSAParser.COMMA, i);
		}
		public Stat_ioexprContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterStat_ioexpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitStat_ioexpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStat_ioexpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Stat_assignmentContext : StatementContext {
		public AssignmentContext assignment() {
			return GetRuleContext<AssignmentContext>(0);
		}
		public Stat_assignmentContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterStat_assignment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitStat_assignment(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStat_assignment(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Stat_whileContext : StatementContext {
		public WhileloopContext whileloop() {
			return GetRuleContext<WhileloopContext>(0);
		}
		public Stat_whileContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterStat_while(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitStat_while(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStat_while(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Stat_switchContext : StatementContext {
		public SwitchcontrolContext switchcontrol() {
			return GetRuleContext<SwitchcontrolContext>(0);
		}
		public Stat_switchContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterStat_switch(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitStat_switch(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStat_switch(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Stat_exprContext : StatementContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Stat_exprContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterStat_expr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitStat_expr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStat_expr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_statement);
		int _la;
		try {
			State = 91;
			switch ( Interpreter.AdaptivePredict(_input,5,_ctx) ) {
			case 1:
				_localctx = new Stat_exprContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 76; expression(0);
				}
				break;

			case 2:
				_localctx = new Stat_assignmentContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 77; assignment();
				}
				break;

			case 3:
				_localctx = new Stat_ioexprContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 78; keyword();
				State = 79; expression(0);
				State = 84;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 80; Match(COMMA);
					State = 81; expression(0);
					}
					}
					State = 86;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
				break;

			case 4:
				_localctx = new Stat_ifctrlContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 87; ifcontrol();
				}
				break;

			case 5:
				_localctx = new Stat_dowhileContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 88; dowhileloop();
				}
				break;

			case 6:
				_localctx = new Stat_whileContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 89; whileloop();
				}
				break;

			case 7:
				_localctx = new Stat_switchContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 90; switchcontrol();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclarationsContext : ParserRuleContext {
		public DeclarationsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declarations; } }
	 
		public DeclarationsContext() { }
		public virtual void CopyFrom(DeclarationsContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ConstdeclContext : DeclarationsContext {
		public ConstantdeclarationsContext constantdeclarations() {
			return GetRuleContext<ConstantdeclarationsContext>(0);
		}
		public ConstdeclContext(DeclarationsContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterConstdecl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitConstdecl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstdecl(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class VardeclContext : DeclarationsContext {
		public VariabledeclarationsContext variabledeclarations() {
			return GetRuleContext<VariabledeclarationsContext>(0);
		}
		public VardeclContext(DeclarationsContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterVardecl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitVardecl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVardecl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclarationsContext declarations() {
		DeclarationsContext _localctx = new DeclarationsContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_declarations);
		try {
			State = 95;
			switch (_input.La(1)) {
			case METABLHTES:
				_localctx = new VardeclContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 93; variabledeclarations();
				}
				break;
			case STATHERES:
				_localctx = new ConstdeclContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 94; constantdeclarations();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctiondefinitionContext : ParserRuleContext {
		public FunctiondefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functiondefinition; } }
	 
		public FunctiondefinitionContext() { }
		public virtual void CopyFrom(FunctiondefinitionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Funcdef1Context : FunctiondefinitionContext {
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public FunctionargumentsContext functionarguments() {
			return GetRuleContext<FunctionargumentsContext>(0);
		}
		public ITerminalNode SYNARTHSH() { return GetToken(GLOSSAParser.SYNARTHSH, 0); }
		public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public ITerminalNode IDENTIFIER() { return GetToken(GLOSSAParser.IDENTIFIER, 0); }
		public ITerminalNode TELOS_SYNARTHSHS() { return GetToken(GLOSSAParser.TELOS_SYNARTHSHS, 0); }
		public Funcdef1Context(FunctiondefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterFuncdef1(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitFuncdef1(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFuncdef1(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctiondefinitionContext functiondefinition() {
		FunctiondefinitionContext _localctx = new FunctiondefinitionContext(_ctx, State);
		EnterRule(_localctx, 10, RULE_functiondefinition);
		int _la;
		try {
			_localctx = new Funcdef1Context(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 97; Match(SYNARTHSH);
			State = 98; Match(IDENTIFIER);
			State = 100;
			_la = _input.La(1);
			if (_la==IDENTIFIER) {
				{
				State = 99; functionarguments();
				}
			}

			State = 102; Match(T__0);
			State = 103; type();
			State = 104; statementlist();
			State = 105; Match(TELOS_SYNARTHSHS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProceduredefinitionContext : ParserRuleContext {
		public ProceduredefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_proceduredefinition; } }
	 
		public ProceduredefinitionContext() { }
		public virtual void CopyFrom(ProceduredefinitionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Procdef1Context : ProceduredefinitionContext {
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public FunctionargumentsContext functionarguments() {
			return GetRuleContext<FunctionargumentsContext>(0);
		}
		public ITerminalNode TELOS_DIADIKASIAS() { return GetToken(GLOSSAParser.TELOS_DIADIKASIAS, 0); }
		public ITerminalNode DIADIKASIA() { return GetToken(GLOSSAParser.DIADIKASIA, 0); }
		public ITerminalNode IDENTIFIER() { return GetToken(GLOSSAParser.IDENTIFIER, 0); }
		public Procdef1Context(ProceduredefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterProcdef1(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitProcdef1(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProcdef1(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ProceduredefinitionContext proceduredefinition() {
		ProceduredefinitionContext _localctx = new ProceduredefinitionContext(_ctx, State);
		EnterRule(_localctx, 12, RULE_proceduredefinition);
		try {
			_localctx = new Procdef1Context(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 107; Match(DIADIKASIA);
			State = 108; Match(IDENTIFIER);
			State = 110;
			switch ( Interpreter.AdaptivePredict(_input,8,_ctx) ) {
			case 1:
				{
				State = 109; functionarguments();
				}
				break;
			}
			State = 112; statementlist();
			State = 113; Match(TELOS_DIADIKASIAS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VariabledeclarationsContext : ParserRuleContext {
		public VariabledeclarationsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variabledeclarations; } }
	 
		public VariabledeclarationsContext() { }
		public virtual void CopyFrom(VariabledeclarationsContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Vardecl_alt2Context : VariabledeclarationsContext {
		public TypeContext type(int i) {
			return GetRuleContext<TypeContext>(i);
		}
		public ITerminalNode IDENTIFIER(int i) {
			return GetToken(GLOSSAParser.IDENTIFIER, i);
		}
		public IReadOnlyList<TypeContext> type() {
			return GetRuleContexts<TypeContext>();
		}
		public ITerminalNode METABLHTES() { return GetToken(GLOSSAParser.METABLHTES, 0); }
		public IReadOnlyList<ITerminalNode> IDENTIFIER() { return GetTokens(GLOSSAParser.IDENTIFIER); }
		public Vardecl_alt2Context(VariabledeclarationsContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterVardecl_alt2(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitVardecl_alt2(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVardecl_alt2(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Vardecl_alt1Context : VariabledeclarationsContext {
		public ITerminalNode IDENTIFIER(int i) {
			return GetToken(GLOSSAParser.IDENTIFIER, i);
		}
		public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public ITerminalNode METABLHTES() { return GetToken(GLOSSAParser.METABLHTES, 0); }
		public IReadOnlyList<ITerminalNode> IDENTIFIER() { return GetTokens(GLOSSAParser.IDENTIFIER); }
		public Vardecl_alt1Context(VariabledeclarationsContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterVardecl_alt1(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitVardecl_alt1(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVardecl_alt1(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VariabledeclarationsContext variabledeclarations() {
		VariabledeclarationsContext _localctx = new VariabledeclarationsContext(_ctx, State);
		EnterRule(_localctx, 14, RULE_variabledeclarations);
		int _la;
		try {
			State = 135;
			switch ( Interpreter.AdaptivePredict(_input,11,_ctx) ) {
			case 1:
				_localctx = new Vardecl_alt1Context(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 115; Match(METABLHTES);
				State = 116; type();
				State = 117; Match(T__0);
				State = 118; Match(IDENTIFIER);
				State = 123;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 119; Match(COMMA);
					State = 120; Match(IDENTIFIER);
					}
					}
					State = 125;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
				break;

			case 2:
				_localctx = new Vardecl_alt2Context(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 126; Match(METABLHTES);
				State = 131;
				_errHandler.Sync(this);
				_la = _input.La(1);
				do {
					{
					{
					State = 127; type();
					State = 128; Match(T__0);
					State = 129; Match(IDENTIFIER);
					}
					}
					State = 133;
					_errHandler.Sync(this);
					_la = _input.La(1);
				} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AKERAIES) | (1L << PRAGMATIKES) | (1L << XARAKTHRES) | (1L << LOGIKES))) != 0) );
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstantdeclarationsContext : ParserRuleContext {
		public ConstantdeclarationsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constantdeclarations; } }
	 
		public ConstantdeclarationsContext() { }
		public virtual void CopyFrom(ConstantdeclarationsContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Constdecl_alt1Context : ConstantdeclarationsContext {
		public IReadOnlyList<ITerminalNode> EQUALS() { return GetTokens(GLOSSAParser.EQUALS); }
		public ITerminalNode STATHERES() { return GetToken(GLOSSAParser.STATHERES, 0); }
		public ITerminalNode IDENTIFIER(int i) {
			return GetToken(GLOSSAParser.IDENTIFIER, i);
		}
		public ITerminalNode EQUALS(int i) {
			return GetToken(GLOSSAParser.EQUALS, i);
		}
		public IReadOnlyList<ITerminalNode> IDENTIFIER() { return GetTokens(GLOSSAParser.IDENTIFIER); }
		public IReadOnlyList<ExpressionprimitivesContext> expressionprimitives() {
			return GetRuleContexts<ExpressionprimitivesContext>();
		}
		public ExpressionprimitivesContext expressionprimitives(int i) {
			return GetRuleContext<ExpressionprimitivesContext>(i);
		}
		public Constdecl_alt1Context(ConstantdeclarationsContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterConstdecl_alt1(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitConstdecl_alt1(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstdecl_alt1(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConstantdeclarationsContext constantdeclarations() {
		ConstantdeclarationsContext _localctx = new ConstantdeclarationsContext(_ctx, State);
		EnterRule(_localctx, 16, RULE_constantdeclarations);
		int _la;
		try {
			_localctx = new Constdecl_alt1Context(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 137; Match(STATHERES);
			State = 141;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 138; Match(IDENTIFIER);
				State = 139; Match(EQUALS);
				State = 140; expressionprimitives();
				}
				}
				State = 143;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==IDENTIFIER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfcontrolContext : ParserRuleContext {
		public IfcontrolContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifcontrol; } }
	 
		public IfcontrolContext() { }
		public virtual void CopyFrom(IfcontrolContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class IfctrlContext : IfcontrolContext {
		public IReadOnlyList<ElseifContext> elseif() {
			return GetRuleContexts<ElseifContext>();
		}
		public ITerminalNode TOTE() { return GetToken(GLOSSAParser.TOTE, 0); }
		public ITerminalNode TELOS_AN() { return GetToken(GLOSSAParser.TELOS_AN, 0); }
		public ITerminalNode AN() { return GetToken(GLOSSAParser.AN, 0); }
		public ElseContext @else() {
			return GetRuleContext<ElseContext>(0);
		}
		public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public ElseifContext elseif(int i) {
			return GetRuleContext<ElseifContext>(i);
		}
		public IReadOnlyList<StatementContext> statement() {
			return GetRuleContexts<StatementContext>();
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public IfctrlContext(IfcontrolContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterIfctrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitIfctrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfctrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IfcontrolContext ifcontrol() {
		IfcontrolContext _localctx = new IfcontrolContext(_ctx, State);
		EnterRule(_localctx, 18, RULE_ifcontrol);
		int _la;
		try {
			_localctx = new IfctrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 145; Match(AN);
			State = 146; expression(0);
			State = 147; Match(TOTE);
			State = 151;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AN) | (1L << ARXH_EPANALIPSIS) | (1L << OSO) | (1L << EPILEKSE) | (1L << GRAPSE) | (1L << EKTIPOSE) | (1L << DIABASE) | (1L << KALESE) | (1L << OXI) | (1L << INTEGER) | (1L << DECIMAL) | (1L << STRING) | (1L << IDENTIFIER) | (1L << PLUS) | (1L << MINUS) | (1L << LPAREN))) != 0)) {
				{
				{
				State = 148; statement();
				}
				}
				State = 153;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 157;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==ALLIOS_AN) {
				{
				{
				State = 154; elseif();
				}
				}
				State = 159;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 161;
			_la = _input.La(1);
			if (_la==ALLIOS) {
				{
				State = 160; @else();
				}
			}

			State = 163; Match(TELOS_AN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElseifContext : ParserRuleContext {
		public ElseifContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elseif; } }
	 
		public ElseifContext() { }
		public virtual void CopyFrom(ElseifContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ElseifctrlContext : ElseifContext {
		public ITerminalNode TOTE() { return GetToken(GLOSSAParser.TOTE, 0); }
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public ITerminalNode ALLIOS_AN() { return GetToken(GLOSSAParser.ALLIOS_AN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ElseifctrlContext(ElseifContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterElseifctrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitElseifctrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElseifctrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElseifContext elseif() {
		ElseifContext _localctx = new ElseifContext(_ctx, State);
		EnterRule(_localctx, 20, RULE_elseif);
		try {
			_localctx = new ElseifctrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 165; Match(ALLIOS_AN);
			State = 166; expression(0);
			State = 167; Match(TOTE);
			State = 168; statementlist();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElseContext : ParserRuleContext {
		public ElseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_else; } }
	 
		public ElseContext() { }
		public virtual void CopyFrom(ElseContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ElsectrlContext : ElseContext {
		public ITerminalNode ALLIOS() { return GetToken(GLOSSAParser.ALLIOS, 0); }
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public ElsectrlContext(ElseContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterElsectrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitElsectrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElsectrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElseContext @else() {
		ElseContext _localctx = new ElseContext(_ctx, State);
		EnterRule(_localctx, 22, RULE_else);
		try {
			_localctx = new ElsectrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 170; Match(ALLIOS);
			State = 171; statementlist();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DowhileloopContext : ParserRuleContext {
		public DowhileloopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dowhileloop; } }
	 
		public DowhileloopContext() { }
		public virtual void CopyFrom(DowhileloopContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class DowhilectrlContext : DowhileloopContext {
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public ITerminalNode MEXRIS_OTOU() { return GetToken(GLOSSAParser.MEXRIS_OTOU, 0); }
		public ITerminalNode ARXH_EPANALIPSIS() { return GetToken(GLOSSAParser.ARXH_EPANALIPSIS, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public DowhilectrlContext(DowhileloopContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterDowhilectrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitDowhilectrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDowhilectrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DowhileloopContext dowhileloop() {
		DowhileloopContext _localctx = new DowhileloopContext(_ctx, State);
		EnterRule(_localctx, 24, RULE_dowhileloop);
		try {
			_localctx = new DowhilectrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 173; Match(ARXH_EPANALIPSIS);
			State = 174; statementlist();
			State = 175; Match(MEXRIS_OTOU);
			State = 176; expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhileloopContext : ParserRuleContext {
		public WhileloopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whileloop; } }
	 
		public WhileloopContext() { }
		public virtual void CopyFrom(WhileloopContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class WhilectrlContext : WhileloopContext {
		public ITerminalNode EPANALABE() { return GetToken(GLOSSAParser.EPANALABE, 0); }
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public ITerminalNode OSO() { return GetToken(GLOSSAParser.OSO, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode TELOS_EPANALIPSIS() { return GetToken(GLOSSAParser.TELOS_EPANALIPSIS, 0); }
		public WhilectrlContext(WhileloopContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterWhilectrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitWhilectrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhilectrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WhileloopContext whileloop() {
		WhileloopContext _localctx = new WhileloopContext(_ctx, State);
		EnterRule(_localctx, 26, RULE_whileloop);
		try {
			_localctx = new WhilectrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 178; Match(OSO);
			State = 179; expression(0);
			State = 180; Match(EPANALABE);
			State = 181; statementlist();
			State = 182; Match(TELOS_EPANALIPSIS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForloopContext : ParserRuleContext {
		public ForloopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forloop; } }
	 
		public ForloopContext() { }
		public virtual void CopyFrom(ForloopContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ForctrlContext : ForloopContext {
		public ITerminalNode ME_BHMA() { return GetToken(GLOSSAParser.ME_BHMA, 0); }
		public IReadOnlyList<ITerminalNode> INTEGER() { return GetTokens(GLOSSAParser.INTEGER); }
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public ITerminalNode MEXRI() { return GetToken(GLOSSAParser.MEXRI, 0); }
		public ITerminalNode APO() { return GetToken(GLOSSAParser.APO, 0); }
		public ITerminalNode INTEGER(int i) {
			return GetToken(GLOSSAParser.INTEGER, i);
		}
		public ITerminalNode IDENTIFIER() { return GetToken(GLOSSAParser.IDENTIFIER, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode TELOS_EPANALIPSIS() { return GetToken(GLOSSAParser.TELOS_EPANALIPSIS, 0); }
		public ITerminalNode GIA() { return GetToken(GLOSSAParser.GIA, 0); }
		public ForctrlContext(ForloopContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterForctrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitForctrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitForctrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ForloopContext forloop() {
		ForloopContext _localctx = new ForloopContext(_ctx, State);
		EnterRule(_localctx, 28, RULE_forloop);
		try {
			_localctx = new ForctrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 184; Match(GIA);
			State = 185; Match(IDENTIFIER);
			State = 186; Match(APO);
			State = 187; Match(INTEGER);
			State = 188; Match(MEXRI);
			State = 189; Match(INTEGER);
			State = 190; Match(ME_BHMA);
			State = 191; expression(0);
			State = 192; statementlist();
			State = 193; Match(TELOS_EPANALIPSIS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SwitchcontrolContext : ParserRuleContext {
		public SwitchcontrolContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_switchcontrol; } }
	 
		public SwitchcontrolContext() { }
		public virtual void CopyFrom(SwitchcontrolContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class SwitchctrlContext : SwitchcontrolContext {
		public ITerminalNode EPILEKSE() { return GetToken(GLOSSAParser.EPILEKSE, 0); }
		public ITerminalNode IDENTIFIER() { return GetToken(GLOSSAParser.IDENTIFIER, 0); }
		public ITerminalNode TELOS_EPILOGON() { return GetToken(GLOSSAParser.TELOS_EPILOGON, 0); }
		public IReadOnlyList<CasescontrolContext> casescontrol() {
			return GetRuleContexts<CasescontrolContext>();
		}
		public CasescontrolContext casescontrol(int i) {
			return GetRuleContext<CasescontrolContext>(i);
		}
		public IReadOnlyList<OtherwisecontrolContext> otherwisecontrol() {
			return GetRuleContexts<OtherwisecontrolContext>();
		}
		public OtherwisecontrolContext otherwisecontrol(int i) {
			return GetRuleContext<OtherwisecontrolContext>(i);
		}
		public SwitchctrlContext(SwitchcontrolContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterSwitchctrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitSwitchctrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSwitchctrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SwitchcontrolContext switchcontrol() {
		SwitchcontrolContext _localctx = new SwitchcontrolContext(_ctx, State);
		EnterRule(_localctx, 30, RULE_switchcontrol);
		int _la;
		try {
			int _alt;
			_localctx = new SwitchctrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 195; Match(EPILEKSE);
			State = 196; Match(IDENTIFIER);
			State = 198;
			_errHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 197; casescontrol();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 200;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,16,_ctx);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber );
			State = 205;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==PERIPTOSI) {
				{
				{
				State = 202; otherwisecontrol();
				}
				}
				State = 207;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 208; Match(TELOS_EPILOGON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CasescontrolContext : ParserRuleContext {
		public CasescontrolContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_casescontrol; } }
	 
		public CasescontrolContext() { }
		public virtual void CopyFrom(CasescontrolContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class CasectrlContext : CasescontrolContext {
		public ITerminalNode PERIPTOSI() { return GetToken(GLOSSAParser.PERIPTOSI, 0); }
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public CasectrlContext(CasescontrolContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterCasectrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitCasectrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCasectrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CasescontrolContext casescontrol() {
		CasescontrolContext _localctx = new CasescontrolContext(_ctx, State);
		EnterRule(_localctx, 32, RULE_casescontrol);
		try {
			_localctx = new CasectrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 210; Match(PERIPTOSI);
			State = 211; expression(0);
			State = 212; statementlist();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OtherwisecontrolContext : ParserRuleContext {
		public OtherwisecontrolContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_otherwisecontrol; } }
	 
		public OtherwisecontrolContext() { }
		public virtual void CopyFrom(OtherwisecontrolContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class OtherwisectrlContext : OtherwisecontrolContext {
		public ITerminalNode PERIPTOSI() { return GetToken(GLOSSAParser.PERIPTOSI, 0); }
		public ITerminalNode ALLIOS() { return GetToken(GLOSSAParser.ALLIOS, 0); }
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public OtherwisectrlContext(OtherwisecontrolContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterOtherwisectrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitOtherwisectrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOtherwisectrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OtherwisecontrolContext otherwisecontrol() {
		OtherwisecontrolContext _localctx = new OtherwisecontrolContext(_ctx, State);
		EnterRule(_localctx, 34, RULE_otherwisecontrol);
		try {
			_localctx = new OtherwisectrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 214; Match(PERIPTOSI);
			State = 215; Match(ALLIOS);
			State = 216; statementlist();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionargumentsContext : ParserRuleContext {
		public FunctionargumentsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionarguments; } }
	 
		public FunctionargumentsContext() { }
		public virtual void CopyFrom(FunctionargumentsContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class FunargsContext : FunctionargumentsContext {
		public IReadOnlyList<ITerminalNode> COMMA() { return GetTokens(GLOSSAParser.COMMA); }
		public ITerminalNode IDENTIFIER(int i) {
			return GetToken(GLOSSAParser.IDENTIFIER, i);
		}
		public IReadOnlyList<ITerminalNode> IDENTIFIER() { return GetTokens(GLOSSAParser.IDENTIFIER); }
		public ITerminalNode COMMA(int i) {
			return GetToken(GLOSSAParser.COMMA, i);
		}
		public FunargsContext(FunctionargumentsContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterFunargs(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitFunargs(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunargs(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionargumentsContext functionarguments() {
		FunctionargumentsContext _localctx = new FunctionargumentsContext(_ctx, State);
		EnterRule(_localctx, 36, RULE_functionarguments);
		int _la;
		try {
			_localctx = new FunargsContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 218; Match(IDENTIFIER);
			State = 223;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 219; Match(COMMA);
				State = 220; Match(IDENTIFIER);
				}
				}
				State = 225;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AssignmentContext : ParserRuleContext {
		public AssignmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assignment; } }
	 
		public AssignmentContext() { }
		public virtual void CopyFrom(AssignmentContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class AssignContext : AssignmentContext {
		public ITerminalNode ASSIGNMENT() { return GetToken(GLOSSAParser.ASSIGNMENT, 0); }
		public ITerminalNode IDENTIFIER() { return GetToken(GLOSSAParser.IDENTIFIER, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public AssignContext(AssignmentContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterAssign(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitAssign(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssign(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AssignmentContext assignment() {
		AssignmentContext _localctx = new AssignmentContext(_ctx, State);
		EnterRule(_localctx, 38, RULE_assignment);
		try {
			_localctx = new AssignContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 226; Match(IDENTIFIER);
			State = 227; Match(ASSIGNMENT);
			State = 228; expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionprimitivesContext : ParserRuleContext {
		public ExpressionprimitivesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionprimitives; } }
	 
		public ExpressionprimitivesContext() { }
		public virtual void CopyFrom(ExpressionprimitivesContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Expressionprimitives_stringContext : ExpressionprimitivesContext {
		public ITerminalNode STRING() { return GetToken(GLOSSAParser.STRING, 0); }
		public Expressionprimitives_stringContext(ExpressionprimitivesContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpressionprimitives_string(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpressionprimitives_string(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionprimitives_string(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expressionprimitives_intContext : ExpressionprimitivesContext {
		public ITerminalNode INTEGER() { return GetToken(GLOSSAParser.INTEGER, 0); }
		public Expressionprimitives_intContext(ExpressionprimitivesContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpressionprimitives_int(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpressionprimitives_int(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionprimitives_int(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expressionprimitives_decContext : ExpressionprimitivesContext {
		public ITerminalNode DECIMAL() { return GetToken(GLOSSAParser.DECIMAL, 0); }
		public Expressionprimitives_decContext(ExpressionprimitivesContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpressionprimitives_dec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpressionprimitives_dec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionprimitives_dec(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expressionprimitives_identifierContext : ExpressionprimitivesContext {
		public ITerminalNode IDENTIFIER() { return GetToken(GLOSSAParser.IDENTIFIER, 0); }
		public Expressionprimitives_identifierContext(ExpressionprimitivesContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpressionprimitives_identifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpressionprimitives_identifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionprimitives_identifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionprimitivesContext expressionprimitives() {
		ExpressionprimitivesContext _localctx = new ExpressionprimitivesContext(_ctx, State);
		EnterRule(_localctx, 40, RULE_expressionprimitives);
		try {
			State = 234;
			switch (_input.La(1)) {
			case INTEGER:
				_localctx = new Expressionprimitives_intContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 230; Match(INTEGER);
				}
				break;
			case DECIMAL:
				_localctx = new Expressionprimitives_decContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 231; Match(DECIMAL);
				}
				break;
			case STRING:
				_localctx = new Expressionprimitives_stringContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 232; Match(STRING);
				}
				break;
			case IDENTIFIER:
				_localctx = new Expressionprimitives_identifierContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 233; Match(IDENTIFIER);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
	 
		public ExpressionContext() { }
		public virtual void CopyFrom(ExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Expr_compareContext : ExpressionContext {
		public IToken op;
		public ITerminalNode EQUALS() { return GetToken(GLOSSAParser.EQUALS, 0); }
		public ITerminalNode GE() { return GetToken(GLOSSAParser.GE, 0); }
		public ITerminalNode NOTEQUALS() { return GetToken(GLOSSAParser.NOTEQUALS, 0); }
		public ITerminalNode LT() { return GetToken(GLOSSAParser.LT, 0); }
		public ITerminalNode GT() { return GetToken(GLOSSAParser.GT, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode LE() { return GetToken(GLOSSAParser.LE, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public Expr_compareContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_compare(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_compare(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_compare(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_muldivContext : ExpressionContext {
		public IToken op;
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode DIV() { return GetToken(GLOSSAParser.DIV, 0); }
		public ITerminalNode MUL() { return GetToken(GLOSSAParser.MUL, 0); }
		public Expr_muldivContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_muldiv(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_muldiv(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_muldiv(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_orContext : ExpressionContext {
		public ITerminalNode H() { return GetToken(GLOSSAParser.H, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public Expr_orContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_or(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_or(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_or(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_powerContext : ExpressionContext {
		public ITerminalNode POWER() { return GetToken(GLOSSAParser.POWER, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public Expr_powerContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_power(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_power(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_power(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_andContext : ExpressionContext {
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode KAI() { return GetToken(GLOSSAParser.KAI, 0); }
		public Expr_andContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_and(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_and(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_and(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_parenContext : ExpressionContext {
		public ITerminalNode LPAREN() { return GetToken(GLOSSAParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(GLOSSAParser.RPAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Expr_parenContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_paren(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_paren(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_paren(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_funcproccallContext : ExpressionContext {
		public FunctionargumentsContext functionarguments() {
			return GetRuleContext<FunctionargumentsContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(GLOSSAParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(GLOSSAParser.RPAREN, 0); }
		public ITerminalNode IDENTIFIER() { return GetToken(GLOSSAParser.IDENTIFIER, 0); }
		public Expr_funcproccallContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_funcproccall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_funcproccall(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_funcproccall(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_expressionprimitivesContext : ExpressionContext {
		public ExpressionprimitivesContext expressionprimitives() {
			return GetRuleContext<ExpressionprimitivesContext>(0);
		}
		public Expr_expressionprimitivesContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_expressionprimitives(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_expressionprimitives(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_expressionprimitives(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_unaryContext : ExpressionContext {
		public IToken op;
		public ITerminalNode PLUS() { return GetToken(GLOSSAParser.PLUS, 0); }
		public ITerminalNode MINUS() { return GetToken(GLOSSAParser.MINUS, 0); }
		public ITerminalNode OXI() { return GetToken(GLOSSAParser.OXI, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Expr_unaryContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_unary(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_unary(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_unary(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_plusminusContext : ExpressionContext {
		public IToken op;
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode PLUS() { return GetToken(GLOSSAParser.PLUS, 0); }
		public ITerminalNode MINUS() { return GetToken(GLOSSAParser.MINUS, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public Expr_plusminusContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_plusminus(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_plusminus(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_plusminus(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		return expression(0);
	}

	private ExpressionContext expression(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		ExpressionContext _localctx = new ExpressionContext(_ctx, _parentState);
		ExpressionContext _prevctx = _localctx;
		int _startState = 42;
		EnterRecursionRule(_localctx, 42, RULE_expression, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 250;
			switch ( Interpreter.AdaptivePredict(_input,21,_ctx) ) {
			case 1:
				{
				_localctx = new Expr_unaryContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;

				State = 237;
				((Expr_unaryContext)_localctx).op = _input.Lt(1);
				_la = _input.La(1);
				if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << OXI) | (1L << PLUS) | (1L << MINUS))) != 0)) ) {
					((Expr_unaryContext)_localctx).op = _errHandler.RecoverInline(this);
				}
				Consume();
				State = 238; expression(8);
				}
				break;

			case 2:
				{
				_localctx = new Expr_parenContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 239; Match(LPAREN);
				State = 240; expression(0);
				State = 241; Match(RPAREN);
				}
				break;

			case 3:
				{
				_localctx = new Expr_funcproccallContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 243; Match(IDENTIFIER);
				State = 244; Match(LPAREN);
				State = 246;
				_la = _input.La(1);
				if (_la==IDENTIFIER) {
					{
					State = 245; functionarguments();
					}
				}

				State = 248; Match(RPAREN);
				}
				break;

			case 4:
				{
				_localctx = new Expr_expressionprimitivesContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 249; expressionprimitives();
				}
				break;
			}
			_ctx.stop = _input.Lt(-1);
			State = 272;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,23,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 270;
					switch ( Interpreter.AdaptivePredict(_input,22,_ctx) ) {
					case 1:
						{
						_localctx = new Expr_powerContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 252;
						if (!(Precpred(_ctx, 9))) throw new FailedPredicateException(this, "Precpred(_ctx, 9)");
						State = 253; Match(POWER);
						State = 254; expression(9);
						}
						break;

					case 2:
						{
						_localctx = new Expr_muldivContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 255;
						if (!(Precpred(_ctx, 7))) throw new FailedPredicateException(this, "Precpred(_ctx, 7)");
						State = 256;
						((Expr_muldivContext)_localctx).op = _input.Lt(1);
						_la = _input.La(1);
						if ( !(_la==MUL || _la==DIV) ) {
							((Expr_muldivContext)_localctx).op = _errHandler.RecoverInline(this);
						}
						Consume();
						State = 257; expression(8);
						}
						break;

					case 3:
						{
						_localctx = new Expr_plusminusContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 258;
						if (!(Precpred(_ctx, 6))) throw new FailedPredicateException(this, "Precpred(_ctx, 6)");
						State = 259;
						((Expr_plusminusContext)_localctx).op = _input.Lt(1);
						_la = _input.La(1);
						if ( !(_la==PLUS || _la==MINUS) ) {
							((Expr_plusminusContext)_localctx).op = _errHandler.RecoverInline(this);
						}
						Consume();
						State = 260; expression(7);
						}
						break;

					case 4:
						{
						_localctx = new Expr_compareContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 261;
						if (!(Precpred(_ctx, 5))) throw new FailedPredicateException(this, "Precpred(_ctx, 5)");
						State = 262;
						((Expr_compareContext)_localctx).op = _input.Lt(1);
						_la = _input.La(1);
						if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << EQUALS) | (1L << NOTEQUALS) | (1L << GT) | (1L << GE) | (1L << LT) | (1L << LE))) != 0)) ) {
							((Expr_compareContext)_localctx).op = _errHandler.RecoverInline(this);
						}
						Consume();
						State = 263; expression(6);
						}
						break;

					case 5:
						{
						_localctx = new Expr_andContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 264;
						if (!(Precpred(_ctx, 4))) throw new FailedPredicateException(this, "Precpred(_ctx, 4)");
						State = 265; Match(KAI);
						State = 266; expression(5);
						}
						break;

					case 6:
						{
						_localctx = new Expr_orContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 267;
						if (!(Precpred(_ctx, 3))) throw new FailedPredicateException(this, "Precpred(_ctx, 3)");
						State = 268; Match(H);
						State = 269; expression(4);
						}
						break;
					}
					} 
				}
				State = 274;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,23,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class TypeContext : ParserRuleContext {
		public TypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type; } }
	 
		public TypeContext() { }
		public virtual void CopyFrom(TypeContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Type_pragmatikesContext : TypeContext {
		public ITerminalNode PRAGMATIKES() { return GetToken(GLOSSAParser.PRAGMATIKES, 0); }
		public Type_pragmatikesContext(TypeContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterType_pragmatikes(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitType_pragmatikes(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_pragmatikes(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Type_xaraktiresContext : TypeContext {
		public ITerminalNode XARAKTHRES() { return GetToken(GLOSSAParser.XARAKTHRES, 0); }
		public Type_xaraktiresContext(TypeContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterType_xaraktires(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitType_xaraktires(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_xaraktires(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Type_akeraiesContext : TypeContext {
		public ITerminalNode AKERAIES() { return GetToken(GLOSSAParser.AKERAIES, 0); }
		public Type_akeraiesContext(TypeContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterType_akeraies(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitType_akeraies(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_akeraies(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Type_logikesContext : TypeContext {
		public ITerminalNode LOGIKES() { return GetToken(GLOSSAParser.LOGIKES, 0); }
		public Type_logikesContext(TypeContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterType_logikes(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitType_logikes(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_logikes(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeContext type() {
		TypeContext _localctx = new TypeContext(_ctx, State);
		EnterRule(_localctx, 44, RULE_type);
		try {
			State = 279;
			switch (_input.La(1)) {
			case AKERAIES:
				_localctx = new Type_akeraiesContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 275; Match(AKERAIES);
				}
				break;
			case PRAGMATIKES:
				_localctx = new Type_pragmatikesContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 276; Match(PRAGMATIKES);
				}
				break;
			case XARAKTHRES:
				_localctx = new Type_xaraktiresContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 277; Match(XARAKTHRES);
				}
				break;
			case LOGIKES:
				_localctx = new Type_logikesContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 278; Match(LOGIKES);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class KeywordContext : ParserRuleContext {
		public KeywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_keyword; } }
	 
		public KeywordContext() { }
		public virtual void CopyFrom(KeywordContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Keyword_kaleseContext : KeywordContext {
		public ITerminalNode KALESE() { return GetToken(GLOSSAParser.KALESE, 0); }
		public Keyword_kaleseContext(KeywordContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterKeyword_kalese(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitKeyword_kalese(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitKeyword_kalese(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Keyword_diabaseContext : KeywordContext {
		public ITerminalNode DIABASE() { return GetToken(GLOSSAParser.DIABASE, 0); }
		public Keyword_diabaseContext(KeywordContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterKeyword_diabase(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitKeyword_diabase(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitKeyword_diabase(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Keyword_ektiposeContext : KeywordContext {
		public ITerminalNode EKTIPOSE() { return GetToken(GLOSSAParser.EKTIPOSE, 0); }
		public Keyword_ektiposeContext(KeywordContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterKeyword_ektipose(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitKeyword_ektipose(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitKeyword_ektipose(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Keyword_grapseContext : KeywordContext {
		public ITerminalNode GRAPSE() { return GetToken(GLOSSAParser.GRAPSE, 0); }
		public Keyword_grapseContext(KeywordContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterKeyword_grapse(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitKeyword_grapse(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitKeyword_grapse(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public KeywordContext keyword() {
		KeywordContext _localctx = new KeywordContext(_ctx, State);
		EnterRule(_localctx, 46, RULE_keyword);
		try {
			State = 285;
			switch (_input.La(1)) {
			case GRAPSE:
				_localctx = new Keyword_grapseContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 281; Match(GRAPSE);
				}
				break;
			case EKTIPOSE:
				_localctx = new Keyword_ektiposeContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 282; Match(EKTIPOSE);
				}
				break;
			case DIABASE:
				_localctx = new Keyword_diabaseContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 283; Match(DIABASE);
				}
				break;
			case KALESE:
				_localctx = new Keyword_kaleseContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 284; Match(KALESE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BoolContext : ParserRuleContext {
		public BoolContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bool; } }
	 
		public BoolContext() { }
		public virtual void CopyFrom(BoolContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Bool_trueContext : BoolContext {
		public ITerminalNode TRUE() { return GetToken(GLOSSAParser.TRUE, 0); }
		public Bool_trueContext(BoolContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterBool_true(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitBool_true(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBool_true(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Bool_falseContext : BoolContext {
		public ITerminalNode FALSE() { return GetToken(GLOSSAParser.FALSE, 0); }
		public Bool_falseContext(BoolContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterBool_false(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitBool_false(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBool_false(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BoolContext @bool() {
		BoolContext _localctx = new BoolContext(_ctx, State);
		EnterRule(_localctx, 48, RULE_bool);
		try {
			State = 289;
			switch (_input.La(1)) {
			case TRUE:
				_localctx = new Bool_trueContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 287; Match(TRUE);
				}
				break;
			case FALSE:
				_localctx = new Bool_falseContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 288; Match(FALSE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 21: return expression_sempred((ExpressionContext)_localctx, predIndex);
		}
		return true;
	}
	private bool expression_sempred(ExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(_ctx, 9);

		case 1: return Precpred(_ctx, 7);

		case 2: return Precpred(_ctx, 6);

		case 3: return Precpred(_ctx, 5);

		case 4: return Precpred(_ctx, 4);

		case 5: return Precpred(_ctx, 3);
		}
		return true;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3\x44\x126\x4\x2"+
		"\t\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4"+
		"\t\t\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10"+
		"\t\x10\x4\x11\t\x11\x4\x12\t\x12\x4\x13\t\x13\x4\x14\t\x14\x4\x15\t\x15"+
		"\x4\x16\t\x16\x4\x17\t\x17\x4\x18\t\x18\x4\x19\t\x19\x4\x1A\t\x1A\x3\x2"+
		"\x3\x2\x3\x2\a\x2\x38\n\x2\f\x2\xE\x2;\v\x2\x3\x3\x3\x3\x3\x3\a\x3@\n"+
		"\x3\f\x3\xE\x3\x43\v\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x4\a\x4J\n\x4\f\x4"+
		"\xE\x4M\v\x4\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\a\x5U\n\x5\f\x5\xE\x5"+
		"X\v\x5\x3\x5\x3\x5\x3\x5\x3\x5\x5\x5^\n\x5\x3\x6\x3\x6\x5\x6\x62\n\x6"+
		"\x3\a\x3\a\x3\a\x5\ag\n\a\x3\a\x3\a\x3\a\x3\a\x3\a\x3\b\x3\b\x3\b\x5\b"+
		"q\n\b\x3\b\x3\b\x3\b\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\a\t|\n\t\f\t\xE\t\x7F"+
		"\v\t\x3\t\x3\t\x3\t\x3\t\x3\t\x6\t\x86\n\t\r\t\xE\t\x87\x5\t\x8A\n\t\x3"+
		"\n\x3\n\x3\n\x3\n\x6\n\x90\n\n\r\n\xE\n\x91\x3\v\x3\v\x3\v\x3\v\a\v\x98"+
		"\n\v\f\v\xE\v\x9B\v\v\x3\v\a\v\x9E\n\v\f\v\xE\v\xA1\v\v\x3\v\x5\v\xA4"+
		"\n\v\x3\v\x3\v\x3\f\x3\f\x3\f\x3\f\x3\f\x3\r\x3\r\x3\r\x3\xE\x3\xE\x3"+
		"\xE\x3\xE\x3\xE\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\x10\x3\x10\x3\x10"+
		"\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x3\x11\x3\x11"+
		"\x3\x11\x6\x11\xC9\n\x11\r\x11\xE\x11\xCA\x3\x11\a\x11\xCE\n\x11\f\x11"+
		"\xE\x11\xD1\v\x11\x3\x11\x3\x11\x3\x12\x3\x12\x3\x12\x3\x12\x3\x13\x3"+
		"\x13\x3\x13\x3\x13\x3\x14\x3\x14\x3\x14\a\x14\xE0\n\x14\f\x14\xE\x14\xE3"+
		"\v\x14\x3\x15\x3\x15\x3\x15\x3\x15\x3\x16\x3\x16\x3\x16\x3\x16\x5\x16"+
		"\xED\n\x16\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3"+
		"\x17\x3\x17\x5\x17\xF9\n\x17\x3\x17\x3\x17\x5\x17\xFD\n\x17\x3\x17\x3"+
		"\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3"+
		"\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\a\x17\x111\n\x17\f\x17"+
		"\xE\x17\x114\v\x17\x3\x18\x3\x18\x3\x18\x3\x18\x5\x18\x11A\n\x18\x3\x19"+
		"\x3\x19\x3\x19\x3\x19\x5\x19\x120\n\x19\x3\x1A\x3\x1A\x5\x1A\x124\n\x1A"+
		"\x3\x1A\x2\x2\x3,\x1B\x2\x2\x4\x2\x6\x2\b\x2\n\x2\f\x2\xE\x2\x10\x2\x12"+
		"\x2\x14\x2\x16\x2\x18\x2\x1A\x2\x1C\x2\x1E\x2 \x2\"\x2$\x2&\x2(\x2*\x2"+
		",\x2.\x2\x30\x2\x32\x2\x2\x6\x4\x2**\x35\x36\x3\x2\x37\x38\x3\x2\x35\x36"+
		"\x3\x2/\x34\x138\x2\x34\x3\x2\x2\x2\x4<\x3\x2\x2\x2\x6K\x3\x2\x2\x2\b"+
		"]\x3\x2\x2\x2\n\x61\x3\x2\x2\x2\f\x63\x3\x2\x2\x2\xEm\x3\x2\x2\x2\x10"+
		"\x89\x3\x2\x2\x2\x12\x8B\x3\x2\x2\x2\x14\x93\x3\x2\x2\x2\x16\xA7\x3\x2"+
		"\x2\x2\x18\xAC\x3\x2\x2\x2\x1A\xAF\x3\x2\x2\x2\x1C\xB4\x3\x2\x2\x2\x1E"+
		"\xBA\x3\x2\x2\x2 \xC5\x3\x2\x2\x2\"\xD4\x3\x2\x2\x2$\xD8\x3\x2\x2\x2&"+
		"\xDC\x3\x2\x2\x2(\xE4\x3\x2\x2\x2*\xEC\x3\x2\x2\x2,\xFC\x3\x2\x2\x2.\x119"+
		"\x3\x2\x2\x2\x30\x11F\x3\x2\x2\x2\x32\x123\x3\x2\x2\x2\x34\x39\x5\x4\x3"+
		"\x2\x35\x38\x5\f\a\x2\x36\x38\x5\xE\b\x2\x37\x35\x3\x2\x2\x2\x37\x36\x3"+
		"\x2\x2\x2\x38;\x3\x2\x2\x2\x39\x37\x3\x2\x2\x2\x39:\x3\x2\x2\x2:\x3\x3"+
		"\x2\x2\x2;\x39\x3\x2\x2\x2<=\a\x4\x2\x2=\x41\a.\x2\x2>@\x5\n\x6\x2?>\x3"+
		"\x2\x2\x2@\x43\x3\x2\x2\x2\x41?\x3\x2\x2\x2\x41\x42\x3\x2\x2\x2\x42\x44"+
		"\x3\x2\x2\x2\x43\x41\x3\x2\x2\x2\x44\x45\a\x5\x2\x2\x45\x46\x5\x6\x4\x2"+
		"\x46G\a\x6\x2\x2G\x5\x3\x2\x2\x2HJ\x5\b\x5\x2IH\x3\x2\x2\x2JM\x3\x2\x2"+
		"\x2KI\x3\x2\x2\x2KL\x3\x2\x2\x2L\a\x3\x2\x2\x2MK\x3\x2\x2\x2N^\x5,\x17"+
		"\x2O^\x5(\x15\x2PQ\x5\x30\x19\x2QV\x5,\x17\x2RS\a;\x2\x2SU\x5,\x17\x2"+
		"TR\x3\x2\x2\x2UX\x3\x2\x2\x2VT\x3\x2\x2\x2VW\x3\x2\x2\x2W^\x3\x2\x2\x2"+
		"XV\x3\x2\x2\x2Y^\x5\x14\v\x2Z^\x5\x1A\xE\x2[^\x5\x1C\xF\x2\\^\x5 \x11"+
		"\x2]N\x3\x2\x2\x2]O\x3\x2\x2\x2]P\x3\x2\x2\x2]Y\x3\x2\x2\x2]Z\x3\x2\x2"+
		"\x2][\x3\x2\x2\x2]\\\x3\x2\x2\x2^\t\x3\x2\x2\x2_\x62\x5\x10\t\x2`\x62"+
		"\x5\x12\n\x2\x61_\x3\x2\x2\x2\x61`\x3\x2\x2\x2\x62\v\x3\x2\x2\x2\x63\x64"+
		"\a\a\x2\x2\x64\x66\a.\x2\x2\x65g\x5&\x14\x2\x66\x65\x3\x2\x2\x2\x66g\x3"+
		"\x2\x2\x2gh\x3\x2\x2\x2hi\a\x3\x2\x2ij\x5.\x18\x2jk\x5\x6\x4\x2kl\a\b"+
		"\x2\x2l\r\x3\x2\x2\x2mn\a\t\x2\x2np\a.\x2\x2oq\x5&\x14\x2po\x3\x2\x2\x2"+
		"pq\x3\x2\x2\x2qr\x3\x2\x2\x2rs\x5\x6\x4\x2st\a\n\x2\x2t\xF\x3\x2\x2\x2"+
		"uv\a\v\x2\x2vw\x5.\x18\x2wx\a\x3\x2\x2x}\a.\x2\x2yz\a;\x2\x2z|\a.\x2\x2"+
		"{y\x3\x2\x2\x2|\x7F\x3\x2\x2\x2}{\x3\x2\x2\x2}~\x3\x2\x2\x2~\x8A\x3\x2"+
		"\x2\x2\x7F}\x3\x2\x2\x2\x80\x85\a\v\x2\x2\x81\x82\x5.\x18\x2\x82\x83\a"+
		"\x3\x2\x2\x83\x84\a.\x2\x2\x84\x86\x3\x2\x2\x2\x85\x81\x3\x2\x2\x2\x86"+
		"\x87\x3\x2\x2\x2\x87\x85\x3\x2\x2\x2\x87\x88\x3\x2\x2\x2\x88\x8A\x3\x2"+
		"\x2\x2\x89u\x3\x2\x2\x2\x89\x80\x3\x2\x2\x2\x8A\x11\x3\x2\x2\x2\x8B\x8F"+
		"\a\f\x2\x2\x8C\x8D\a.\x2\x2\x8D\x8E\a/\x2\x2\x8E\x90\x5*\x16\x2\x8F\x8C"+
		"\x3\x2\x2\x2\x90\x91\x3\x2\x2\x2\x91\x8F\x3\x2\x2\x2\x91\x92\x3\x2\x2"+
		"\x2\x92\x13\x3\x2\x2\x2\x93\x94\a\r\x2\x2\x94\x95\x5,\x17\x2\x95\x99\a"+
		"\xE\x2\x2\x96\x98\x5\b\x5\x2\x97\x96\x3\x2\x2\x2\x98\x9B\x3\x2\x2\x2\x99"+
		"\x97\x3\x2\x2\x2\x99\x9A\x3\x2\x2\x2\x9A\x9F\x3\x2\x2\x2\x9B\x99\x3\x2"+
		"\x2\x2\x9C\x9E\x5\x16\f\x2\x9D\x9C\x3\x2\x2\x2\x9E\xA1\x3\x2\x2\x2\x9F"+
		"\x9D\x3\x2\x2\x2\x9F\xA0\x3\x2\x2\x2\xA0\xA3\x3\x2\x2\x2\xA1\x9F\x3\x2"+
		"\x2\x2\xA2\xA4\x5\x18\r\x2\xA3\xA2\x3\x2\x2\x2\xA3\xA4\x3\x2\x2\x2\xA4"+
		"\xA5\x3\x2\x2\x2\xA5\xA6\a\xF\x2\x2\xA6\x15\x3\x2\x2\x2\xA7\xA8\a\x10"+
		"\x2\x2\xA8\xA9\x5,\x17\x2\xA9\xAA\a\xE\x2\x2\xAA\xAB\x5\x6\x4\x2\xAB\x17"+
		"\x3\x2\x2\x2\xAC\xAD\a\x11\x2\x2\xAD\xAE\x5\x6\x4\x2\xAE\x19\x3\x2\x2"+
		"\x2\xAF\xB0\a\x12\x2\x2\xB0\xB1\x5\x6\x4\x2\xB1\xB2\a\x13\x2\x2\xB2\xB3"+
		"\x5,\x17\x2\xB3\x1B\x3\x2\x2\x2\xB4\xB5\a\x14\x2\x2\xB5\xB6\x5,\x17\x2"+
		"\xB6\xB7\a\x15\x2\x2\xB7\xB8\x5\x6\x4\x2\xB8\xB9\a\x16\x2\x2\xB9\x1D\x3"+
		"\x2\x2\x2\xBA\xBB\a\x17\x2\x2\xBB\xBC\a.\x2\x2\xBC\xBD\a\x18\x2\x2\xBD"+
		"\xBE\a+\x2\x2\xBE\xBF\a\x19\x2\x2\xBF\xC0\a+\x2\x2\xC0\xC1\a\x1A\x2\x2"+
		"\xC1\xC2\x5,\x17\x2\xC2\xC3\x5\x6\x4\x2\xC3\xC4\a\x16\x2\x2\xC4\x1F\x3"+
		"\x2\x2\x2\xC5\xC6\a\x1B\x2\x2\xC6\xC8\a.\x2\x2\xC7\xC9\x5\"\x12\x2\xC8"+
		"\xC7\x3\x2\x2\x2\xC9\xCA\x3\x2\x2\x2\xCA\xC8\x3\x2\x2\x2\xCA\xCB\x3\x2"+
		"\x2\x2\xCB\xCF\x3\x2\x2\x2\xCC\xCE\x5$\x13\x2\xCD\xCC\x3\x2\x2\x2\xCE"+
		"\xD1\x3\x2\x2\x2\xCF\xCD\x3\x2\x2\x2\xCF\xD0\x3\x2\x2\x2\xD0\xD2\x3\x2"+
		"\x2\x2\xD1\xCF\x3\x2\x2\x2\xD2\xD3\a\x1D\x2\x2\xD3!\x3\x2\x2\x2\xD4\xD5"+
		"\a\x1C\x2\x2\xD5\xD6\x5,\x17\x2\xD6\xD7\x5\x6\x4\x2\xD7#\x3\x2\x2\x2\xD8"+
		"\xD9\a\x1C\x2\x2\xD9\xDA\a\x11\x2\x2\xDA\xDB\x5\x6\x4\x2\xDB%\x3\x2\x2"+
		"\x2\xDC\xE1\a.\x2\x2\xDD\xDE\a;\x2\x2\xDE\xE0\a.\x2\x2\xDF\xDD\x3\x2\x2"+
		"\x2\xE0\xE3\x3\x2\x2\x2\xE1\xDF\x3\x2\x2\x2\xE1\xE2\x3\x2\x2\x2\xE2\'"+
		"\x3\x2\x2\x2\xE3\xE1\x3\x2\x2\x2\xE4\xE5\a.\x2\x2\xE5\xE6\a<\x2\x2\xE6"+
		"\xE7\x5,\x17\x2\xE7)\x3\x2\x2\x2\xE8\xED\a+\x2\x2\xE9\xED\a,\x2\x2\xEA"+
		"\xED\a-\x2\x2\xEB\xED\a.\x2\x2\xEC\xE8\x3\x2\x2\x2\xEC\xE9\x3\x2\x2\x2"+
		"\xEC\xEA\x3\x2\x2\x2\xEC\xEB\x3\x2\x2\x2\xED+\x3\x2\x2\x2\xEE\xEF\b\x17"+
		"\x1\x2\xEF\xF0\t\x2\x2\x2\xF0\xFD\x5,\x17\n\xF1\xF2\a=\x2\x2\xF2\xF3\x5"+
		",\x17\x2\xF3\xF4\a>\x2\x2\xF4\xFD\x3\x2\x2\x2\xF5\xF6\a.\x2\x2\xF6\xF8"+
		"\a=\x2\x2\xF7\xF9\x5&\x14\x2\xF8\xF7\x3\x2\x2\x2\xF8\xF9\x3\x2\x2\x2\xF9"+
		"\xFA\x3\x2\x2\x2\xFA\xFD\a>\x2\x2\xFB\xFD\x5*\x16\x2\xFC\xEE\x3\x2\x2"+
		"\x2\xFC\xF1\x3\x2\x2\x2\xFC\xF5\x3\x2\x2\x2\xFC\xFB\x3\x2\x2\x2\xFD\x112"+
		"\x3\x2\x2\x2\xFE\xFF\f\v\x2\x2\xFF\x100\a\x39\x2\x2\x100\x111\x5,\x17"+
		"\v\x101\x102\f\t\x2\x2\x102\x103\t\x3\x2\x2\x103\x111\x5,\x17\n\x104\x105"+
		"\f\b\x2\x2\x105\x106\t\x4\x2\x2\x106\x111\x5,\x17\t\x107\x108\f\a\x2\x2"+
		"\x108\x109\t\x5\x2\x2\x109\x111\x5,\x17\b\x10A\x10B\f\x6\x2\x2\x10B\x10C"+
		"\a(\x2\x2\x10C\x111\x5,\x17\a\x10D\x10E\f\x5\x2\x2\x10E\x10F\a)\x2\x2"+
		"\x10F\x111\x5,\x17\x6\x110\xFE\x3\x2\x2\x2\x110\x101\x3\x2\x2\x2\x110"+
		"\x104\x3\x2\x2\x2\x110\x107\x3\x2\x2\x2\x110\x10A\x3\x2\x2\x2\x110\x10D"+
		"\x3\x2\x2\x2\x111\x114\x3\x2\x2\x2\x112\x110\x3\x2\x2\x2\x112\x113\x3"+
		"\x2\x2\x2\x113-\x3\x2\x2\x2\x114\x112\x3\x2\x2\x2\x115\x11A\a\x1E\x2\x2"+
		"\x116\x11A\a\x1F\x2\x2\x117\x11A\a \x2\x2\x118\x11A\a!\x2\x2\x119\x115"+
		"\x3\x2\x2\x2\x119\x116\x3\x2\x2\x2\x119\x117\x3\x2\x2\x2\x119\x118\x3"+
		"\x2\x2\x2\x11A/\x3\x2\x2\x2\x11B\x120\a\"\x2\x2\x11C\x120\a#\x2\x2\x11D"+
		"\x120\a$\x2\x2\x11E\x120\a%\x2\x2\x11F\x11B\x3\x2\x2\x2\x11F\x11C\x3\x2"+
		"\x2\x2\x11F\x11D\x3\x2\x2\x2\x11F\x11E\x3\x2\x2\x2\x120\x31\x3\x2\x2\x2"+
		"\x121\x124\a&\x2\x2\x122\x124\a\'\x2\x2\x123\x121\x3\x2\x2\x2\x123\x122"+
		"\x3\x2\x2\x2\x124\x33\x3\x2\x2\x2\x1D\x37\x39\x41KV]\x61\x66p}\x87\x89"+
		"\x91\x99\x9F\xA3\xCA\xCF\xE1\xEC\xF8\xFC\x110\x112\x119\x11F\x123";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace Glossa
