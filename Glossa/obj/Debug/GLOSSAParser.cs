//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.4.1-SNAPSHOT
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:\Users\Sonic\Documents\Visual Studio 2013\Projects\Glossa\Glossa\GLOSSA.g4 by ANTLR 4.4.1-SNAPSHOT

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591

namespace Glossa {
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.4.1-SNAPSHOT")]
[System.CLSCompliant(false)]
public partial class GLOSSAParser : Parser {
	public const int
		T__0=1, PROGRAMMA=2, ARXH=3, TELOS_PROGRAMMATOS=4, SYNARTHSH=5, TELOS_SYNARTHSHS=6, 
		DIADIKASIA=7, TELOS_DIADIKASIAS=8, METABLHTES=9, STATHERES=10, AN=11, 
		TOTE=12, TELOS_AN=13, ALLIOS_AN=14, ALLIOS=15, ARXH_EPANALIPSIS=16, MEXRIS_OTOU=17, 
		OSO=18, EPANALABE=19, TELOS_EPANALIPSIS=20, GIA=21, APO=22, MEXRI=23, 
		ME_BHMA=24, EPILEKSE=25, PERIPTOSI=26, TELOS_EPILOGON=27, AKERAIA=28, 
		PRAGMATIKI=29, XARAKTHRAS=30, LOGIKI=31, AKERAIES=32, PRAGMATIKES=33, 
		XARAKTHRES=34, LOGIKES=35, GRAPSE=36, EKTIPOSE=37, DIABASE=38, KALESE=39, 
		TRUE=40, FALSE=41, KAI=42, H=43, OXI=44, INTEGER=45, DECIMAL=46, STRING=47, 
		IDENTIFIER=48, EQUALS=49, NOTEQUALS=50, GT=51, GE=52, LT=53, LE=54, PLUS=55, 
		MINUS=56, MUL=57, DIV=58, POWER=59, SEMICOLON=60, COMMA=61, ASSIGNMENT=62, 
		LPAREN=63, RPAREN=64, LBRACKET=65, RBRACKET=66, LANCHOR=67, RANCHOR=68, 
		COMMENTS=69, WS=70;
	public const int
		RULE_file = 0, RULE_program = 1, RULE_functiondefinition = 2, RULE_proceduredefinition = 3, 
		RULE_statementlist = 4, RULE_statement = 5, RULE_declarations = 6, RULE_variabledeclarations = 7, 
		RULE_constantdeclarations = 8, RULE_ifcontrol = 9, RULE_elseif = 10, RULE_else = 11, 
		RULE_dowhileloop = 12, RULE_whileloop = 13, RULE_forloop = 14, RULE_switchcontrol = 15, 
		RULE_casescontrol = 16, RULE_otherwisecontrol = 17, RULE_functionarguments = 18, 
		RULE_assignment = 19, RULE_expressionprimitives = 20, RULE_expression = 21, 
		RULE_type = 22, RULE_functionType = 23, RULE_keyword = 24, RULE_bool = 25;
	public static readonly string[] ruleNames = {
		"file", "program", "functiondefinition", "proceduredefinition", "statementlist", 
		"statement", "declarations", "variabledeclarations", "constantdeclarations", 
		"ifcontrol", "elseif", "else", "dowhileloop", "whileloop", "forloop", 
		"switchcontrol", "casescontrol", "otherwisecontrol", "functionarguments", 
		"assignment", "expressionprimitives", "expression", "type", "functionType", 
		"keyword", "bool"
	};

	private static readonly string[] _LiteralNames = {
		null, "':'", "'пяоцяалла'", "'аявг'", "'текос_пяоцяаллатос'", "'сумаятгсг'", 
		"'текос_сумаятгсгс'", "'диадийасиа'", "'текос_диадийасиас'", "'летабкгтес'", 
		"'стахеяес'", "'ам'", "'тоте'", "'текос_ам'", "'аккиыс_ам'", "'аккиыс'", 
		"'аявг_епамакгьгс'", "'левяис_отоу'", "'осо'", "'епамакабе'", "'текос_епамакгьгс'", 
		"'циа'", "'апо'", "'левяи'", "'ле_бгла'", "'епикене'", "'пеяиптысг'", 
		"'текос_епикоцым'", "'айеяаиа'", "'пяацлатийг'", "'ваяайтгяас'", "'коцийг'", 
		"'айеяаиес'", "'пяацлатийес'", "'ваяайтгяес'", "'коцийес'", "'цяаье'", 
		"'ейтупысе'", "'диабасе'", "'йакесе'", "'акгхгс'", "'ьеудгс'", "'йаи'", 
		"'г'", "'ови'", null, null, null, null, "'='", "'<>'", "'>'", "'>='", 
		"'<'", "'<='", "'+'", "'-'", "'*'", "'/'", "'^'", "';'", "','", "'<-'", 
		"'('", "')'", "'['", "']'", "'{'", "'}'"
	};
	private static readonly string[] _SymbolicNames = {
		null, null, "PROGRAMMA", "ARXH", "TELOS_PROGRAMMATOS", "SYNARTHSH", "TELOS_SYNARTHSHS", 
		"DIADIKASIA", "TELOS_DIADIKASIAS", "METABLHTES", "STATHERES", "AN", "TOTE", 
		"TELOS_AN", "ALLIOS_AN", "ALLIOS", "ARXH_EPANALIPSIS", "MEXRIS_OTOU", 
		"OSO", "EPANALABE", "TELOS_EPANALIPSIS", "GIA", "APO", "MEXRI", "ME_BHMA", 
		"EPILEKSE", "PERIPTOSI", "TELOS_EPILOGON", "AKERAIA", "PRAGMATIKI", "XARAKTHRAS", 
		"LOGIKI", "AKERAIES", "PRAGMATIKES", "XARAKTHRES", "LOGIKES", "GRAPSE", 
		"EKTIPOSE", "DIABASE", "KALESE", "TRUE", "FALSE", "KAI", "H", "OXI", "INTEGER", 
		"DECIMAL", "STRING", "IDENTIFIER", "EQUALS", "NOTEQUALS", "GT", "GE", 
		"LT", "LE", "PLUS", "MINUS", "MUL", "DIV", "POWER", "SEMICOLON", "COMMA", 
		"ASSIGNMENT", "LPAREN", "RPAREN", "LBRACKET", "RBRACKET", "LANCHOR", "RANCHOR", 
		"COMMENTS", "WS"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[System.Obsolete("Use Vocabulary instead.")]
	public static readonly string[] tokenNames = GenerateTokenNames(DefaultVocabulary, _SymbolicNames.Length);

	private static string[] GenerateTokenNames(IVocabulary vocabulary, int length) {
		string[] tokenNames = new string[length];
		for (int i = 0; i < tokenNames.Length; i++) {
			tokenNames[i] = vocabulary.GetLiteralName(i);
			if (tokenNames[i] == null) {
				tokenNames[i] = vocabulary.GetSymbolicName(i);
			}

			if (tokenNames[i] == null) {
				tokenNames[i] = "<INVALID>";
			}
		}

		return tokenNames;
	}

	[System.Obsolete]
	public override string[] TokenNames
	{
		get
		{
			return tokenNames;
		}
	}

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "GLOSSA.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public GLOSSAParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class FileContext : ParserRuleContext {
		public FileContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_file; } }
	 
		public FileContext() { }
		public virtual void CopyFrom(FileContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class FilestartContext : FileContext {
		public IReadOnlyList<FunctiondefinitionContext> functiondefinition() {
			return GetRuleContexts<FunctiondefinitionContext>();
		}
		public ProgramContext program() {
			return GetRuleContext<ProgramContext>(0);
		}
		public FunctiondefinitionContext functiondefinition(int i) {
			return GetRuleContext<FunctiondefinitionContext>(i);
		}
		public IReadOnlyList<ProceduredefinitionContext> proceduredefinition() {
			return GetRuleContexts<ProceduredefinitionContext>();
		}
		public ProceduredefinitionContext proceduredefinition(int i) {
			return GetRuleContext<ProceduredefinitionContext>(i);
		}
		public FilestartContext(FileContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterFilestart(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitFilestart(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFilestart(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FileContext file() {
		FileContext _localctx = new FileContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_file);
		int _la;
		try {
			_localctx = new FilestartContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 52; program();
			State = 57;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==SYNARTHSH || _la==DIADIKASIA) {
				{
				State = 55;
				switch (_input.La(1)) {
				case SYNARTHSH:
					{
					State = 53; functiondefinition();
					}
					break;
				case DIADIKASIA:
					{
					State = 54; proceduredefinition();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 59;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProgramContext : ParserRuleContext {
		public ProgramContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_program; } }
	 
		public ProgramContext() { }
		public virtual void CopyFrom(ProgramContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ProgramstartContext : ProgramContext {
		public DeclarationsContext declarations(int i) {
			return GetRuleContext<DeclarationsContext>(i);
		}
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public ITerminalNode TELOS_PROGRAMMATOS() { return GetToken(GLOSSAParser.TELOS_PROGRAMMATOS, 0); }
		public IReadOnlyList<DeclarationsContext> declarations() {
			return GetRuleContexts<DeclarationsContext>();
		}
		public ITerminalNode ARXH() { return GetToken(GLOSSAParser.ARXH, 0); }
		public ITerminalNode PROGRAMMA() { return GetToken(GLOSSAParser.PROGRAMMA, 0); }
		public ITerminalNode IDENTIFIER() { return GetToken(GLOSSAParser.IDENTIFIER, 0); }
		public ProgramstartContext(ProgramContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterProgramstart(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitProgramstart(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProgramstart(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ProgramContext program() {
		ProgramContext _localctx = new ProgramContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_program);
		int _la;
		try {
			_localctx = new ProgramstartContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 60; Match(PROGRAMMA);
			State = 61; Match(IDENTIFIER);
			State = 65;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==METABLHTES || _la==STATHERES) {
				{
				{
				State = 62; declarations();
				}
				}
				State = 67;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 68; Match(ARXH);
			State = 69; statementlist();
			State = 70; Match(TELOS_PROGRAMMATOS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctiondefinitionContext : ParserRuleContext {
		public FunctiondefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functiondefinition; } }
	 
		public FunctiondefinitionContext() { }
		public virtual void CopyFrom(FunctiondefinitionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class FuncdefContext : FunctiondefinitionContext {
		public DeclarationsContext declarations(int i) {
			return GetRuleContext<DeclarationsContext>(i);
		}
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public FunctionargumentsContext functionarguments() {
			return GetRuleContext<FunctionargumentsContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(GLOSSAParser.LPAREN, 0); }
		public ITerminalNode SYNARTHSH() { return GetToken(GLOSSAParser.SYNARTHSH, 0); }
		public IReadOnlyList<DeclarationsContext> declarations() {
			return GetRuleContexts<DeclarationsContext>();
		}
		public ITerminalNode ARXH() { return GetToken(GLOSSAParser.ARXH, 0); }
		public FunctionTypeContext functionType() {
			return GetRuleContext<FunctionTypeContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(GLOSSAParser.RPAREN, 0); }
		public ITerminalNode IDENTIFIER() { return GetToken(GLOSSAParser.IDENTIFIER, 0); }
		public ITerminalNode TELOS_SYNARTHSHS() { return GetToken(GLOSSAParser.TELOS_SYNARTHSHS, 0); }
		public FuncdefContext(FunctiondefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterFuncdef(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitFuncdef(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFuncdef(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctiondefinitionContext functiondefinition() {
		FunctiondefinitionContext _localctx = new FunctiondefinitionContext(_ctx, State);
		EnterRule(_localctx, 4, RULE_functiondefinition);
		int _la;
		try {
			_localctx = new FuncdefContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 72; Match(SYNARTHSH);
			State = 73; Match(IDENTIFIER);
			State = 74; Match(LPAREN);
			State = 76;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << INTEGER) | (1L << DECIMAL) | (1L << STRING) | (1L << IDENTIFIER))) != 0)) {
				{
				State = 75; functionarguments();
				}
			}

			State = 78; Match(RPAREN);
			State = 79; Match(T__0);
			State = 80; functionType();
			State = 84;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==METABLHTES || _la==STATHERES) {
				{
				{
				State = 81; declarations();
				}
				}
				State = 86;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 87; Match(ARXH);
			State = 88; statementlist();
			State = 89; Match(TELOS_SYNARTHSHS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProceduredefinitionContext : ParserRuleContext {
		public ProceduredefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_proceduredefinition; } }
	 
		public ProceduredefinitionContext() { }
		public virtual void CopyFrom(ProceduredefinitionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ProcdefContext : ProceduredefinitionContext {
		public DeclarationsContext declarations(int i) {
			return GetRuleContext<DeclarationsContext>(i);
		}
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public FunctionargumentsContext functionarguments() {
			return GetRuleContext<FunctionargumentsContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(GLOSSAParser.LPAREN, 0); }
		public IReadOnlyList<DeclarationsContext> declarations() {
			return GetRuleContexts<DeclarationsContext>();
		}
		public ITerminalNode ARXH() { return GetToken(GLOSSAParser.ARXH, 0); }
		public ITerminalNode RPAREN() { return GetToken(GLOSSAParser.RPAREN, 0); }
		public ITerminalNode TELOS_DIADIKASIAS() { return GetToken(GLOSSAParser.TELOS_DIADIKASIAS, 0); }
		public ITerminalNode DIADIKASIA() { return GetToken(GLOSSAParser.DIADIKASIA, 0); }
		public ITerminalNode IDENTIFIER() { return GetToken(GLOSSAParser.IDENTIFIER, 0); }
		public ProcdefContext(ProceduredefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterProcdef(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitProcdef(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProcdef(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ProceduredefinitionContext proceduredefinition() {
		ProceduredefinitionContext _localctx = new ProceduredefinitionContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_proceduredefinition);
		int _la;
		try {
			_localctx = new ProcdefContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 91; Match(DIADIKASIA);
			State = 92; Match(IDENTIFIER);
			State = 93; Match(LPAREN);
			State = 95;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << INTEGER) | (1L << DECIMAL) | (1L << STRING) | (1L << IDENTIFIER))) != 0)) {
				{
				State = 94; functionarguments();
				}
			}

			State = 97; Match(RPAREN);
			State = 101;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==METABLHTES || _la==STATHERES) {
				{
				{
				State = 98; declarations();
				}
				}
				State = 103;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 104; Match(ARXH);
			State = 105; statementlist();
			State = 106; Match(TELOS_DIADIKASIAS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementlistContext : ParserRuleContext {
		public StatementlistContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statementlist; } }
	 
		public StatementlistContext() { }
		public virtual void CopyFrom(StatementlistContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class StmtlistContext : StatementlistContext {
		public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public IReadOnlyList<StatementContext> statement() {
			return GetRuleContexts<StatementContext>();
		}
		public StmtlistContext(StatementlistContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterStmtlist(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitStmtlist(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStmtlist(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementlistContext statementlist() {
		StatementlistContext _localctx = new StatementlistContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_statementlist);
		int _la;
		try {
			_localctx = new StmtlistContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 111;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AN) | (1L << ARXH_EPANALIPSIS) | (1L << OSO) | (1L << EPILEKSE) | (1L << GRAPSE) | (1L << EKTIPOSE) | (1L << DIABASE) | (1L << KALESE) | (1L << OXI) | (1L << INTEGER) | (1L << DECIMAL) | (1L << STRING) | (1L << IDENTIFIER) | (1L << PLUS) | (1L << MINUS) | (1L << LPAREN))) != 0)) {
				{
				{
				State = 108; statement();
				}
				}
				State = 113;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
	 
		public StatementContext() { }
		public virtual void CopyFrom(StatementContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Stat_ifctrlContext : StatementContext {
		public IfcontrolContext ifcontrol() {
			return GetRuleContext<IfcontrolContext>(0);
		}
		public Stat_ifctrlContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterStat_ifctrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitStat_ifctrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStat_ifctrl(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Stat_dowhileContext : StatementContext {
		public DowhileloopContext dowhileloop() {
			return GetRuleContext<DowhileloopContext>(0);
		}
		public Stat_dowhileContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterStat_dowhile(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitStat_dowhile(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStat_dowhile(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Stat_ioexprContext : StatementContext {
		public IReadOnlyList<ITerminalNode> COMMA() { return GetTokens(GLOSSAParser.COMMA); }
		public KeywordContext keyword() {
			return GetRuleContext<KeywordContext>(0);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode COMMA(int i) {
			return GetToken(GLOSSAParser.COMMA, i);
		}
		public Stat_ioexprContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterStat_ioexpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitStat_ioexpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStat_ioexpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Stat_assignmentContext : StatementContext {
		public AssignmentContext assignment() {
			return GetRuleContext<AssignmentContext>(0);
		}
		public Stat_assignmentContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterStat_assignment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitStat_assignment(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStat_assignment(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Stat_whileContext : StatementContext {
		public WhileloopContext whileloop() {
			return GetRuleContext<WhileloopContext>(0);
		}
		public Stat_whileContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterStat_while(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitStat_while(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStat_while(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Stat_switchContext : StatementContext {
		public SwitchcontrolContext switchcontrol() {
			return GetRuleContext<SwitchcontrolContext>(0);
		}
		public Stat_switchContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterStat_switch(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitStat_switch(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStat_switch(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Stat_exprContext : StatementContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Stat_exprContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterStat_expr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitStat_expr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStat_expr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(_ctx, State);
		EnterRule(_localctx, 10, RULE_statement);
		int _la;
		try {
			State = 129;
			switch ( Interpreter.AdaptivePredict(_input,9,_ctx) ) {
			case 1:
				_localctx = new Stat_exprContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 114; expression(0);
				}
				break;

			case 2:
				_localctx = new Stat_assignmentContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 115; assignment();
				}
				break;

			case 3:
				_localctx = new Stat_ioexprContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 116; keyword();
				State = 117; expression(0);
				State = 122;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 118; Match(COMMA);
					State = 119; expression(0);
					}
					}
					State = 124;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
				break;

			case 4:
				_localctx = new Stat_ifctrlContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 125; ifcontrol();
				}
				break;

			case 5:
				_localctx = new Stat_dowhileContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 126; dowhileloop();
				}
				break;

			case 6:
				_localctx = new Stat_whileContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 127; whileloop();
				}
				break;

			case 7:
				_localctx = new Stat_switchContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 128; switchcontrol();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclarationsContext : ParserRuleContext {
		public DeclarationsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declarations; } }
	 
		public DeclarationsContext() { }
		public virtual void CopyFrom(DeclarationsContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ConstdeclContext : DeclarationsContext {
		public ConstantdeclarationsContext constantdeclarations() {
			return GetRuleContext<ConstantdeclarationsContext>(0);
		}
		public ConstdeclContext(DeclarationsContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterConstdecl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitConstdecl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstdecl(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class VardeclContext : DeclarationsContext {
		public VariabledeclarationsContext variabledeclarations() {
			return GetRuleContext<VariabledeclarationsContext>(0);
		}
		public VardeclContext(DeclarationsContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterVardecl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitVardecl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVardecl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclarationsContext declarations() {
		DeclarationsContext _localctx = new DeclarationsContext(_ctx, State);
		EnterRule(_localctx, 12, RULE_declarations);
		try {
			State = 133;
			switch (_input.La(1)) {
			case METABLHTES:
				_localctx = new VardeclContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 131; variabledeclarations();
				}
				break;
			case STATHERES:
				_localctx = new ConstdeclContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 132; constantdeclarations();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VariabledeclarationsContext : ParserRuleContext {
		public VariabledeclarationsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variabledeclarations; } }
	 
		public VariabledeclarationsContext() { }
		public virtual void CopyFrom(VariabledeclarationsContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Vardecl_alt2Context : VariabledeclarationsContext {
		public TypeContext type(int i) {
			return GetRuleContext<TypeContext>(i);
		}
		public ITerminalNode IDENTIFIER(int i) {
			return GetToken(GLOSSAParser.IDENTIFIER, i);
		}
		public IReadOnlyList<TypeContext> type() {
			return GetRuleContexts<TypeContext>();
		}
		public ITerminalNode METABLHTES() { return GetToken(GLOSSAParser.METABLHTES, 0); }
		public IReadOnlyList<ITerminalNode> IDENTIFIER() { return GetTokens(GLOSSAParser.IDENTIFIER); }
		public Vardecl_alt2Context(VariabledeclarationsContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterVardecl_alt2(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitVardecl_alt2(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVardecl_alt2(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Vardecl_alt1Context : VariabledeclarationsContext {
		public ITerminalNode IDENTIFIER(int i) {
			return GetToken(GLOSSAParser.IDENTIFIER, i);
		}
		public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public ITerminalNode METABLHTES() { return GetToken(GLOSSAParser.METABLHTES, 0); }
		public IReadOnlyList<ITerminalNode> IDENTIFIER() { return GetTokens(GLOSSAParser.IDENTIFIER); }
		public Vardecl_alt1Context(VariabledeclarationsContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterVardecl_alt1(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitVardecl_alt1(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVardecl_alt1(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VariabledeclarationsContext variabledeclarations() {
		VariabledeclarationsContext _localctx = new VariabledeclarationsContext(_ctx, State);
		EnterRule(_localctx, 14, RULE_variabledeclarations);
		int _la;
		try {
			State = 155;
			switch ( Interpreter.AdaptivePredict(_input,13,_ctx) ) {
			case 1:
				_localctx = new Vardecl_alt1Context(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 135; Match(METABLHTES);
				State = 136; type();
				State = 137; Match(T__0);
				State = 138; Match(IDENTIFIER);
				State = 143;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 139; Match(COMMA);
					State = 140; Match(IDENTIFIER);
					}
					}
					State = 145;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
				break;

			case 2:
				_localctx = new Vardecl_alt2Context(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 146; Match(METABLHTES);
				State = 151;
				_errHandler.Sync(this);
				_la = _input.La(1);
				do {
					{
					{
					State = 147; type();
					State = 148; Match(T__0);
					State = 149; Match(IDENTIFIER);
					}
					}
					State = 153;
					_errHandler.Sync(this);
					_la = _input.La(1);
				} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AKERAIES) | (1L << PRAGMATIKES) | (1L << XARAKTHRES) | (1L << LOGIKES))) != 0) );
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstantdeclarationsContext : ParserRuleContext {
		public ConstantdeclarationsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constantdeclarations; } }
	 
		public ConstantdeclarationsContext() { }
		public virtual void CopyFrom(ConstantdeclarationsContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Constdecl_altContext : ConstantdeclarationsContext {
		public IReadOnlyList<ITerminalNode> EQUALS() { return GetTokens(GLOSSAParser.EQUALS); }
		public ITerminalNode STATHERES() { return GetToken(GLOSSAParser.STATHERES, 0); }
		public ITerminalNode IDENTIFIER(int i) {
			return GetToken(GLOSSAParser.IDENTIFIER, i);
		}
		public ITerminalNode EQUALS(int i) {
			return GetToken(GLOSSAParser.EQUALS, i);
		}
		public IReadOnlyList<ITerminalNode> IDENTIFIER() { return GetTokens(GLOSSAParser.IDENTIFIER); }
		public IReadOnlyList<ExpressionprimitivesContext> expressionprimitives() {
			return GetRuleContexts<ExpressionprimitivesContext>();
		}
		public ExpressionprimitivesContext expressionprimitives(int i) {
			return GetRuleContext<ExpressionprimitivesContext>(i);
		}
		public Constdecl_altContext(ConstantdeclarationsContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterConstdecl_alt(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitConstdecl_alt(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstdecl_alt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConstantdeclarationsContext constantdeclarations() {
		ConstantdeclarationsContext _localctx = new ConstantdeclarationsContext(_ctx, State);
		EnterRule(_localctx, 16, RULE_constantdeclarations);
		int _la;
		try {
			_localctx = new Constdecl_altContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 157; Match(STATHERES);
			State = 161;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 158; Match(IDENTIFIER);
				State = 159; Match(EQUALS);
				State = 160; expressionprimitives();
				}
				}
				State = 163;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==IDENTIFIER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfcontrolContext : ParserRuleContext {
		public IfcontrolContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifcontrol; } }
	 
		public IfcontrolContext() { }
		public virtual void CopyFrom(IfcontrolContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class IfctrlContext : IfcontrolContext {
		public IReadOnlyList<ElseifContext> elseif() {
			return GetRuleContexts<ElseifContext>();
		}
		public ITerminalNode TOTE() { return GetToken(GLOSSAParser.TOTE, 0); }
		public ITerminalNode TELOS_AN() { return GetToken(GLOSSAParser.TELOS_AN, 0); }
		public ITerminalNode AN() { return GetToken(GLOSSAParser.AN, 0); }
		public ElseContext @else() {
			return GetRuleContext<ElseContext>(0);
		}
		public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public ElseifContext elseif(int i) {
			return GetRuleContext<ElseifContext>(i);
		}
		public IReadOnlyList<StatementContext> statement() {
			return GetRuleContexts<StatementContext>();
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public IfctrlContext(IfcontrolContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterIfctrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitIfctrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfctrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IfcontrolContext ifcontrol() {
		IfcontrolContext _localctx = new IfcontrolContext(_ctx, State);
		EnterRule(_localctx, 18, RULE_ifcontrol);
		int _la;
		try {
			_localctx = new IfctrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 165; Match(AN);
			State = 166; expression(0);
			State = 167; Match(TOTE);
			State = 171;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AN) | (1L << ARXH_EPANALIPSIS) | (1L << OSO) | (1L << EPILEKSE) | (1L << GRAPSE) | (1L << EKTIPOSE) | (1L << DIABASE) | (1L << KALESE) | (1L << OXI) | (1L << INTEGER) | (1L << DECIMAL) | (1L << STRING) | (1L << IDENTIFIER) | (1L << PLUS) | (1L << MINUS) | (1L << LPAREN))) != 0)) {
				{
				{
				State = 168; statement();
				}
				}
				State = 173;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 177;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==ALLIOS_AN) {
				{
				{
				State = 174; elseif();
				}
				}
				State = 179;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 181;
			_la = _input.La(1);
			if (_la==ALLIOS) {
				{
				State = 180; @else();
				}
			}

			State = 183; Match(TELOS_AN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElseifContext : ParserRuleContext {
		public ElseifContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elseif; } }
	 
		public ElseifContext() { }
		public virtual void CopyFrom(ElseifContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ElseifctrlContext : ElseifContext {
		public ITerminalNode TOTE() { return GetToken(GLOSSAParser.TOTE, 0); }
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public ITerminalNode ALLIOS_AN() { return GetToken(GLOSSAParser.ALLIOS_AN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ElseifctrlContext(ElseifContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterElseifctrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitElseifctrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElseifctrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElseifContext elseif() {
		ElseifContext _localctx = new ElseifContext(_ctx, State);
		EnterRule(_localctx, 20, RULE_elseif);
		try {
			_localctx = new ElseifctrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 185; Match(ALLIOS_AN);
			State = 186; expression(0);
			State = 187; Match(TOTE);
			State = 188; statementlist();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElseContext : ParserRuleContext {
		public ElseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_else; } }
	 
		public ElseContext() { }
		public virtual void CopyFrom(ElseContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ElsectrlContext : ElseContext {
		public ITerminalNode ALLIOS() { return GetToken(GLOSSAParser.ALLIOS, 0); }
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public ElsectrlContext(ElseContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterElsectrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitElsectrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElsectrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElseContext @else() {
		ElseContext _localctx = new ElseContext(_ctx, State);
		EnterRule(_localctx, 22, RULE_else);
		try {
			_localctx = new ElsectrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 190; Match(ALLIOS);
			State = 191; statementlist();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DowhileloopContext : ParserRuleContext {
		public DowhileloopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dowhileloop; } }
	 
		public DowhileloopContext() { }
		public virtual void CopyFrom(DowhileloopContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class DowhilectrlContext : DowhileloopContext {
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public ITerminalNode MEXRIS_OTOU() { return GetToken(GLOSSAParser.MEXRIS_OTOU, 0); }
		public ITerminalNode ARXH_EPANALIPSIS() { return GetToken(GLOSSAParser.ARXH_EPANALIPSIS, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public DowhilectrlContext(DowhileloopContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterDowhilectrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitDowhilectrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDowhilectrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DowhileloopContext dowhileloop() {
		DowhileloopContext _localctx = new DowhileloopContext(_ctx, State);
		EnterRule(_localctx, 24, RULE_dowhileloop);
		try {
			_localctx = new DowhilectrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 193; Match(ARXH_EPANALIPSIS);
			State = 194; statementlist();
			State = 195; Match(MEXRIS_OTOU);
			State = 196; expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhileloopContext : ParserRuleContext {
		public WhileloopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whileloop; } }
	 
		public WhileloopContext() { }
		public virtual void CopyFrom(WhileloopContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class WhilectrlContext : WhileloopContext {
		public ITerminalNode EPANALABE() { return GetToken(GLOSSAParser.EPANALABE, 0); }
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public ITerminalNode OSO() { return GetToken(GLOSSAParser.OSO, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode TELOS_EPANALIPSIS() { return GetToken(GLOSSAParser.TELOS_EPANALIPSIS, 0); }
		public WhilectrlContext(WhileloopContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterWhilectrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitWhilectrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhilectrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WhileloopContext whileloop() {
		WhileloopContext _localctx = new WhileloopContext(_ctx, State);
		EnterRule(_localctx, 26, RULE_whileloop);
		try {
			_localctx = new WhilectrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 198; Match(OSO);
			State = 199; expression(0);
			State = 200; Match(EPANALABE);
			State = 201; statementlist();
			State = 202; Match(TELOS_EPANALIPSIS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForloopContext : ParserRuleContext {
		public ForloopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forloop; } }
	 
		public ForloopContext() { }
		public virtual void CopyFrom(ForloopContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ForctrlContext : ForloopContext {
		public ITerminalNode ME_BHMA() { return GetToken(GLOSSAParser.ME_BHMA, 0); }
		public IReadOnlyList<ITerminalNode> INTEGER() { return GetTokens(GLOSSAParser.INTEGER); }
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public ITerminalNode MEXRI() { return GetToken(GLOSSAParser.MEXRI, 0); }
		public ITerminalNode APO() { return GetToken(GLOSSAParser.APO, 0); }
		public ITerminalNode INTEGER(int i) {
			return GetToken(GLOSSAParser.INTEGER, i);
		}
		public ITerminalNode IDENTIFIER() { return GetToken(GLOSSAParser.IDENTIFIER, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode TELOS_EPANALIPSIS() { return GetToken(GLOSSAParser.TELOS_EPANALIPSIS, 0); }
		public ITerminalNode GIA() { return GetToken(GLOSSAParser.GIA, 0); }
		public ForctrlContext(ForloopContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterForctrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitForctrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitForctrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ForloopContext forloop() {
		ForloopContext _localctx = new ForloopContext(_ctx, State);
		EnterRule(_localctx, 28, RULE_forloop);
		try {
			_localctx = new ForctrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 204; Match(GIA);
			State = 205; Match(IDENTIFIER);
			State = 206; Match(APO);
			State = 207; Match(INTEGER);
			State = 208; Match(MEXRI);
			State = 209; Match(INTEGER);
			State = 210; Match(ME_BHMA);
			State = 211; expression(0);
			State = 212; statementlist();
			State = 213; Match(TELOS_EPANALIPSIS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SwitchcontrolContext : ParserRuleContext {
		public SwitchcontrolContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_switchcontrol; } }
	 
		public SwitchcontrolContext() { }
		public virtual void CopyFrom(SwitchcontrolContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class SwitchctrlContext : SwitchcontrolContext {
		public ITerminalNode EPILEKSE() { return GetToken(GLOSSAParser.EPILEKSE, 0); }
		public ITerminalNode IDENTIFIER() { return GetToken(GLOSSAParser.IDENTIFIER, 0); }
		public ITerminalNode TELOS_EPILOGON() { return GetToken(GLOSSAParser.TELOS_EPILOGON, 0); }
		public IReadOnlyList<CasescontrolContext> casescontrol() {
			return GetRuleContexts<CasescontrolContext>();
		}
		public CasescontrolContext casescontrol(int i) {
			return GetRuleContext<CasescontrolContext>(i);
		}
		public IReadOnlyList<OtherwisecontrolContext> otherwisecontrol() {
			return GetRuleContexts<OtherwisecontrolContext>();
		}
		public OtherwisecontrolContext otherwisecontrol(int i) {
			return GetRuleContext<OtherwisecontrolContext>(i);
		}
		public SwitchctrlContext(SwitchcontrolContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterSwitchctrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitSwitchctrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSwitchctrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SwitchcontrolContext switchcontrol() {
		SwitchcontrolContext _localctx = new SwitchcontrolContext(_ctx, State);
		EnterRule(_localctx, 30, RULE_switchcontrol);
		int _la;
		try {
			int _alt;
			_localctx = new SwitchctrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 215; Match(EPILEKSE);
			State = 216; Match(IDENTIFIER);
			State = 218;
			_errHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 217; casescontrol();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 220;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,18,_ctx);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber );
			State = 225;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==PERIPTOSI) {
				{
				{
				State = 222; otherwisecontrol();
				}
				}
				State = 227;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 228; Match(TELOS_EPILOGON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CasescontrolContext : ParserRuleContext {
		public CasescontrolContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_casescontrol; } }
	 
		public CasescontrolContext() { }
		public virtual void CopyFrom(CasescontrolContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class CasectrlContext : CasescontrolContext {
		public ITerminalNode PERIPTOSI() { return GetToken(GLOSSAParser.PERIPTOSI, 0); }
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public CasectrlContext(CasescontrolContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterCasectrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitCasectrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCasectrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CasescontrolContext casescontrol() {
		CasescontrolContext _localctx = new CasescontrolContext(_ctx, State);
		EnterRule(_localctx, 32, RULE_casescontrol);
		try {
			_localctx = new CasectrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 230; Match(PERIPTOSI);
			State = 231; expression(0);
			State = 232; statementlist();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OtherwisecontrolContext : ParserRuleContext {
		public OtherwisecontrolContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_otherwisecontrol; } }
	 
		public OtherwisecontrolContext() { }
		public virtual void CopyFrom(OtherwisecontrolContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class OtherwisectrlContext : OtherwisecontrolContext {
		public ITerminalNode PERIPTOSI() { return GetToken(GLOSSAParser.PERIPTOSI, 0); }
		public ITerminalNode ALLIOS() { return GetToken(GLOSSAParser.ALLIOS, 0); }
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public OtherwisectrlContext(OtherwisecontrolContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterOtherwisectrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitOtherwisectrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOtherwisectrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OtherwisecontrolContext otherwisecontrol() {
		OtherwisecontrolContext _localctx = new OtherwisecontrolContext(_ctx, State);
		EnterRule(_localctx, 34, RULE_otherwisecontrol);
		try {
			_localctx = new OtherwisectrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 234; Match(PERIPTOSI);
			State = 235; Match(ALLIOS);
			State = 236; statementlist();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionargumentsContext : ParserRuleContext {
		public FunctionargumentsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionarguments; } }
	 
		public FunctionargumentsContext() { }
		public virtual void CopyFrom(FunctionargumentsContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class FunargsContext : FunctionargumentsContext {
		public IReadOnlyList<ITerminalNode> COMMA() { return GetTokens(GLOSSAParser.COMMA); }
		public IReadOnlyList<ExpressionprimitivesContext> expressionprimitives() {
			return GetRuleContexts<ExpressionprimitivesContext>();
		}
		public ExpressionprimitivesContext expressionprimitives(int i) {
			return GetRuleContext<ExpressionprimitivesContext>(i);
		}
		public ITerminalNode COMMA(int i) {
			return GetToken(GLOSSAParser.COMMA, i);
		}
		public FunargsContext(FunctionargumentsContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterFunargs(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitFunargs(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunargs(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionargumentsContext functionarguments() {
		FunctionargumentsContext _localctx = new FunctionargumentsContext(_ctx, State);
		EnterRule(_localctx, 36, RULE_functionarguments);
		int _la;
		try {
			_localctx = new FunargsContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 238; expressionprimitives();
			State = 243;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 239; Match(COMMA);
				State = 240; expressionprimitives();
				}
				}
				State = 245;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AssignmentContext : ParserRuleContext {
		public AssignmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assignment; } }
	 
		public AssignmentContext() { }
		public virtual void CopyFrom(AssignmentContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class AssignContext : AssignmentContext {
		public ITerminalNode ASSIGNMENT() { return GetToken(GLOSSAParser.ASSIGNMENT, 0); }
		public ITerminalNode IDENTIFIER() { return GetToken(GLOSSAParser.IDENTIFIER, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public AssignContext(AssignmentContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterAssign(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitAssign(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssign(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AssignmentContext assignment() {
		AssignmentContext _localctx = new AssignmentContext(_ctx, State);
		EnterRule(_localctx, 38, RULE_assignment);
		try {
			_localctx = new AssignContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 246; Match(IDENTIFIER);
			State = 247; Match(ASSIGNMENT);
			State = 248; expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionprimitivesContext : ParserRuleContext {
		public ExpressionprimitivesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionprimitives; } }
	 
		public ExpressionprimitivesContext() { }
		public virtual void CopyFrom(ExpressionprimitivesContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Expressionprimitives_stringContext : ExpressionprimitivesContext {
		public ITerminalNode STRING() { return GetToken(GLOSSAParser.STRING, 0); }
		public Expressionprimitives_stringContext(ExpressionprimitivesContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpressionprimitives_string(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpressionprimitives_string(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionprimitives_string(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expressionprimitives_intContext : ExpressionprimitivesContext {
		public ITerminalNode INTEGER() { return GetToken(GLOSSAParser.INTEGER, 0); }
		public Expressionprimitives_intContext(ExpressionprimitivesContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpressionprimitives_int(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpressionprimitives_int(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionprimitives_int(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expressionprimitives_decContext : ExpressionprimitivesContext {
		public ITerminalNode DECIMAL() { return GetToken(GLOSSAParser.DECIMAL, 0); }
		public Expressionprimitives_decContext(ExpressionprimitivesContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpressionprimitives_dec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpressionprimitives_dec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionprimitives_dec(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expressionprimitives_identifierContext : ExpressionprimitivesContext {
		public ITerminalNode IDENTIFIER() { return GetToken(GLOSSAParser.IDENTIFIER, 0); }
		public Expressionprimitives_identifierContext(ExpressionprimitivesContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpressionprimitives_identifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpressionprimitives_identifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionprimitives_identifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionprimitivesContext expressionprimitives() {
		ExpressionprimitivesContext _localctx = new ExpressionprimitivesContext(_ctx, State);
		EnterRule(_localctx, 40, RULE_expressionprimitives);
		try {
			State = 254;
			switch (_input.La(1)) {
			case INTEGER:
				_localctx = new Expressionprimitives_intContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 250; Match(INTEGER);
				}
				break;
			case DECIMAL:
				_localctx = new Expressionprimitives_decContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 251; Match(DECIMAL);
				}
				break;
			case STRING:
				_localctx = new Expressionprimitives_stringContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 252; Match(STRING);
				}
				break;
			case IDENTIFIER:
				_localctx = new Expressionprimitives_identifierContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 253; Match(IDENTIFIER);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
	 
		public ExpressionContext() { }
		public virtual void CopyFrom(ExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Expr_compareContext : ExpressionContext {
		public IToken op;
		public ITerminalNode EQUALS() { return GetToken(GLOSSAParser.EQUALS, 0); }
		public ITerminalNode GE() { return GetToken(GLOSSAParser.GE, 0); }
		public ITerminalNode NOTEQUALS() { return GetToken(GLOSSAParser.NOTEQUALS, 0); }
		public ITerminalNode LT() { return GetToken(GLOSSAParser.LT, 0); }
		public ITerminalNode GT() { return GetToken(GLOSSAParser.GT, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode LE() { return GetToken(GLOSSAParser.LE, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public Expr_compareContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_compare(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_compare(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_compare(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_muldivContext : ExpressionContext {
		public IToken op;
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode DIV() { return GetToken(GLOSSAParser.DIV, 0); }
		public ITerminalNode MUL() { return GetToken(GLOSSAParser.MUL, 0); }
		public Expr_muldivContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_muldiv(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_muldiv(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_muldiv(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_orContext : ExpressionContext {
		public ITerminalNode H() { return GetToken(GLOSSAParser.H, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public Expr_orContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_or(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_or(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_or(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_powerContext : ExpressionContext {
		public ITerminalNode POWER() { return GetToken(GLOSSAParser.POWER, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public Expr_powerContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_power(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_power(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_power(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_andContext : ExpressionContext {
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode KAI() { return GetToken(GLOSSAParser.KAI, 0); }
		public Expr_andContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_and(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_and(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_and(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_parenContext : ExpressionContext {
		public ITerminalNode LPAREN() { return GetToken(GLOSSAParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(GLOSSAParser.RPAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Expr_parenContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_paren(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_paren(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_paren(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_funcproccallContext : ExpressionContext {
		public FunctionargumentsContext functionarguments() {
			return GetRuleContext<FunctionargumentsContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(GLOSSAParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(GLOSSAParser.RPAREN, 0); }
		public ITerminalNode IDENTIFIER() { return GetToken(GLOSSAParser.IDENTIFIER, 0); }
		public Expr_funcproccallContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_funcproccall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_funcproccall(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_funcproccall(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_expressionprimitivesContext : ExpressionContext {
		public ExpressionprimitivesContext expressionprimitives() {
			return GetRuleContext<ExpressionprimitivesContext>(0);
		}
		public Expr_expressionprimitivesContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_expressionprimitives(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_expressionprimitives(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_expressionprimitives(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_unaryContext : ExpressionContext {
		public IToken op;
		public ITerminalNode PLUS() { return GetToken(GLOSSAParser.PLUS, 0); }
		public ITerminalNode MINUS() { return GetToken(GLOSSAParser.MINUS, 0); }
		public ITerminalNode OXI() { return GetToken(GLOSSAParser.OXI, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Expr_unaryContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_unary(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_unary(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_unary(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_plusminusContext : ExpressionContext {
		public IToken op;
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode PLUS() { return GetToken(GLOSSAParser.PLUS, 0); }
		public ITerminalNode MINUS() { return GetToken(GLOSSAParser.MINUS, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public Expr_plusminusContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_plusminus(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_plusminus(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_plusminus(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		return expression(0);
	}

	private ExpressionContext expression(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		ExpressionContext _localctx = new ExpressionContext(_ctx, _parentState);
		ExpressionContext _prevctx = _localctx;
		int _startState = 42;
		EnterRecursionRule(_localctx, 42, RULE_expression, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 270;
			switch ( Interpreter.AdaptivePredict(_input,23,_ctx) ) {
			case 1:
				{
				_localctx = new Expr_unaryContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;

				State = 257;
				((Expr_unaryContext)_localctx).op = _input.Lt(1);
				_la = _input.La(1);
				if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << OXI) | (1L << PLUS) | (1L << MINUS))) != 0)) ) {
					((Expr_unaryContext)_localctx).op = _errHandler.RecoverInline(this);
				}
				Consume();
				State = 258; expression(8);
				}
				break;

			case 2:
				{
				_localctx = new Expr_parenContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 259; Match(LPAREN);
				State = 260; expression(0);
				State = 261; Match(RPAREN);
				}
				break;

			case 3:
				{
				_localctx = new Expr_funcproccallContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 263; Match(IDENTIFIER);
				State = 264; Match(LPAREN);
				State = 266;
				_la = _input.La(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << INTEGER) | (1L << DECIMAL) | (1L << STRING) | (1L << IDENTIFIER))) != 0)) {
					{
					State = 265; functionarguments();
					}
				}

				State = 268; Match(RPAREN);
				}
				break;

			case 4:
				{
				_localctx = new Expr_expressionprimitivesContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 269; expressionprimitives();
				}
				break;
			}
			_ctx.stop = _input.Lt(-1);
			State = 292;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,25,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 290;
					switch ( Interpreter.AdaptivePredict(_input,24,_ctx) ) {
					case 1:
						{
						_localctx = new Expr_powerContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 272;
						if (!(Precpred(_ctx, 9))) throw new FailedPredicateException(this, "Precpred(_ctx, 9)");
						State = 273; Match(POWER);
						State = 274; expression(9);
						}
						break;

					case 2:
						{
						_localctx = new Expr_muldivContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 275;
						if (!(Precpred(_ctx, 7))) throw new FailedPredicateException(this, "Precpred(_ctx, 7)");
						State = 276;
						((Expr_muldivContext)_localctx).op = _input.Lt(1);
						_la = _input.La(1);
						if ( !(_la==MUL || _la==DIV) ) {
							((Expr_muldivContext)_localctx).op = _errHandler.RecoverInline(this);
						}
						Consume();
						State = 277; expression(8);
						}
						break;

					case 3:
						{
						_localctx = new Expr_plusminusContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 278;
						if (!(Precpred(_ctx, 6))) throw new FailedPredicateException(this, "Precpred(_ctx, 6)");
						State = 279;
						((Expr_plusminusContext)_localctx).op = _input.Lt(1);
						_la = _input.La(1);
						if ( !(_la==PLUS || _la==MINUS) ) {
							((Expr_plusminusContext)_localctx).op = _errHandler.RecoverInline(this);
						}
						Consume();
						State = 280; expression(7);
						}
						break;

					case 4:
						{
						_localctx = new Expr_compareContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 281;
						if (!(Precpred(_ctx, 5))) throw new FailedPredicateException(this, "Precpred(_ctx, 5)");
						State = 282;
						((Expr_compareContext)_localctx).op = _input.Lt(1);
						_la = _input.La(1);
						if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << EQUALS) | (1L << NOTEQUALS) | (1L << GT) | (1L << GE) | (1L << LT) | (1L << LE))) != 0)) ) {
							((Expr_compareContext)_localctx).op = _errHandler.RecoverInline(this);
						}
						Consume();
						State = 283; expression(6);
						}
						break;

					case 5:
						{
						_localctx = new Expr_andContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 284;
						if (!(Precpred(_ctx, 4))) throw new FailedPredicateException(this, "Precpred(_ctx, 4)");
						State = 285; Match(KAI);
						State = 286; expression(5);
						}
						break;

					case 6:
						{
						_localctx = new Expr_orContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 287;
						if (!(Precpred(_ctx, 3))) throw new FailedPredicateException(this, "Precpred(_ctx, 3)");
						State = 288; Match(H);
						State = 289; expression(4);
						}
						break;
					}
					} 
				}
				State = 294;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,25,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class TypeContext : ParserRuleContext {
		public TypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type; } }
	 
		public TypeContext() { }
		public virtual void CopyFrom(TypeContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Type_pragmatikesContext : TypeContext {
		public ITerminalNode PRAGMATIKES() { return GetToken(GLOSSAParser.PRAGMATIKES, 0); }
		public Type_pragmatikesContext(TypeContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterType_pragmatikes(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitType_pragmatikes(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_pragmatikes(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Type_xaraktiresContext : TypeContext {
		public ITerminalNode XARAKTHRES() { return GetToken(GLOSSAParser.XARAKTHRES, 0); }
		public Type_xaraktiresContext(TypeContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterType_xaraktires(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitType_xaraktires(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_xaraktires(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Type_akeraiesContext : TypeContext {
		public ITerminalNode AKERAIES() { return GetToken(GLOSSAParser.AKERAIES, 0); }
		public Type_akeraiesContext(TypeContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterType_akeraies(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitType_akeraies(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_akeraies(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Type_logikesContext : TypeContext {
		public ITerminalNode LOGIKES() { return GetToken(GLOSSAParser.LOGIKES, 0); }
		public Type_logikesContext(TypeContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterType_logikes(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitType_logikes(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_logikes(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeContext type() {
		TypeContext _localctx = new TypeContext(_ctx, State);
		EnterRule(_localctx, 44, RULE_type);
		try {
			State = 299;
			switch (_input.La(1)) {
			case AKERAIES:
				_localctx = new Type_akeraiesContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 295; Match(AKERAIES);
				}
				break;
			case PRAGMATIKES:
				_localctx = new Type_pragmatikesContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 296; Match(PRAGMATIKES);
				}
				break;
			case XARAKTHRES:
				_localctx = new Type_xaraktiresContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 297; Match(XARAKTHRES);
				}
				break;
			case LOGIKES:
				_localctx = new Type_logikesContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 298; Match(LOGIKES);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionTypeContext : ParserRuleContext {
		public ITerminalNode XARAKTHRAS() { return GetToken(GLOSSAParser.XARAKTHRAS, 0); }
		public ITerminalNode LOGIKI() { return GetToken(GLOSSAParser.LOGIKI, 0); }
		public ITerminalNode AKERAIA() { return GetToken(GLOSSAParser.AKERAIA, 0); }
		public ITerminalNode PRAGMATIKI() { return GetToken(GLOSSAParser.PRAGMATIKI, 0); }
		public FunctionTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterFunctionType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitFunctionType(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionTypeContext functionType() {
		FunctionTypeContext _localctx = new FunctionTypeContext(_ctx, State);
		EnterRule(_localctx, 46, RULE_functionType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 301;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AKERAIA) | (1L << PRAGMATIKI) | (1L << XARAKTHRAS) | (1L << LOGIKI))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class KeywordContext : ParserRuleContext {
		public KeywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_keyword; } }
	 
		public KeywordContext() { }
		public virtual void CopyFrom(KeywordContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Keyword_kaleseContext : KeywordContext {
		public ITerminalNode KALESE() { return GetToken(GLOSSAParser.KALESE, 0); }
		public Keyword_kaleseContext(KeywordContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterKeyword_kalese(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitKeyword_kalese(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitKeyword_kalese(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Keyword_diabaseContext : KeywordContext {
		public ITerminalNode DIABASE() { return GetToken(GLOSSAParser.DIABASE, 0); }
		public Keyword_diabaseContext(KeywordContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterKeyword_diabase(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitKeyword_diabase(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitKeyword_diabase(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Keyword_ektiposeContext : KeywordContext {
		public ITerminalNode EKTIPOSE() { return GetToken(GLOSSAParser.EKTIPOSE, 0); }
		public Keyword_ektiposeContext(KeywordContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterKeyword_ektipose(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitKeyword_ektipose(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitKeyword_ektipose(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Keyword_grapseContext : KeywordContext {
		public ITerminalNode GRAPSE() { return GetToken(GLOSSAParser.GRAPSE, 0); }
		public Keyword_grapseContext(KeywordContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterKeyword_grapse(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitKeyword_grapse(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitKeyword_grapse(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public KeywordContext keyword() {
		KeywordContext _localctx = new KeywordContext(_ctx, State);
		EnterRule(_localctx, 48, RULE_keyword);
		try {
			State = 307;
			switch (_input.La(1)) {
			case GRAPSE:
				_localctx = new Keyword_grapseContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 303; Match(GRAPSE);
				}
				break;
			case EKTIPOSE:
				_localctx = new Keyword_ektiposeContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 304; Match(EKTIPOSE);
				}
				break;
			case DIABASE:
				_localctx = new Keyword_diabaseContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 305; Match(DIABASE);
				}
				break;
			case KALESE:
				_localctx = new Keyword_kaleseContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 306; Match(KALESE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BoolContext : ParserRuleContext {
		public BoolContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bool; } }
	 
		public BoolContext() { }
		public virtual void CopyFrom(BoolContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Bool_trueContext : BoolContext {
		public ITerminalNode TRUE() { return GetToken(GLOSSAParser.TRUE, 0); }
		public Bool_trueContext(BoolContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterBool_true(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitBool_true(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBool_true(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Bool_falseContext : BoolContext {
		public ITerminalNode FALSE() { return GetToken(GLOSSAParser.FALSE, 0); }
		public Bool_falseContext(BoolContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterBool_false(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitBool_false(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBool_false(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BoolContext @bool() {
		BoolContext _localctx = new BoolContext(_ctx, State);
		EnterRule(_localctx, 50, RULE_bool);
		try {
			State = 311;
			switch (_input.La(1)) {
			case TRUE:
				_localctx = new Bool_trueContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 309; Match(TRUE);
				}
				break;
			case FALSE:
				_localctx = new Bool_falseContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 310; Match(FALSE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 21: return expression_sempred((ExpressionContext)_localctx, predIndex);
		}
		return true;
	}
	private bool expression_sempred(ExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(_ctx, 9);

		case 1: return Precpred(_ctx, 7);

		case 2: return Precpred(_ctx, 6);

		case 3: return Precpred(_ctx, 5);

		case 4: return Precpred(_ctx, 4);

		case 5: return Precpred(_ctx, 3);
		}
		return true;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3H\x13C\x4\x2\t\x2"+
		"\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4\t\t"+
		"\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10\t"+
		"\x10\x4\x11\t\x11\x4\x12\t\x12\x4\x13\t\x13\x4\x14\t\x14\x4\x15\t\x15"+
		"\x4\x16\t\x16\x4\x17\t\x17\x4\x18\t\x18\x4\x19\t\x19\x4\x1A\t\x1A\x4\x1B"+
		"\t\x1B\x3\x2\x3\x2\x3\x2\a\x2:\n\x2\f\x2\xE\x2=\v\x2\x3\x3\x3\x3\x3\x3"+
		"\a\x3\x42\n\x3\f\x3\xE\x3\x45\v\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x4\x3\x4"+
		"\x3\x4\x3\x4\x5\x4O\n\x4\x3\x4\x3\x4\x3\x4\x3\x4\a\x4U\n\x4\f\x4\xE\x4"+
		"X\v\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x5\x3\x5\x3\x5\x3\x5\x5\x5\x62\n\x5"+
		"\x3\x5\x3\x5\a\x5\x66\n\x5\f\x5\xE\x5i\v\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3"+
		"\x6\a\x6p\n\x6\f\x6\xE\x6s\v\x6\x3\a\x3\a\x3\a\x3\a\x3\a\x3\a\a\a{\n\a"+
		"\f\a\xE\a~\v\a\x3\a\x3\a\x3\a\x3\a\x5\a\x84\n\a\x3\b\x3\b\x5\b\x88\n\b"+
		"\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\a\t\x90\n\t\f\t\xE\t\x93\v\t\x3\t\x3\t"+
		"\x3\t\x3\t\x3\t\x6\t\x9A\n\t\r\t\xE\t\x9B\x5\t\x9E\n\t\x3\n\x3\n\x3\n"+
		"\x3\n\x6\n\xA4\n\n\r\n\xE\n\xA5\x3\v\x3\v\x3\v\x3\v\a\v\xAC\n\v\f\v\xE"+
		"\v\xAF\v\v\x3\v\a\v\xB2\n\v\f\v\xE\v\xB5\v\v\x3\v\x5\v\xB8\n\v\x3\v\x3"+
		"\v\x3\f\x3\f\x3\f\x3\f\x3\f\x3\r\x3\r\x3\r\x3\xE\x3\xE\x3\xE\x3\xE\x3"+
		"\xE\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\x10\x3\x10\x3\x10\x3\x10\x3"+
		"\x10\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x3\x11\x3\x11\x3\x11\x6"+
		"\x11\xDD\n\x11\r\x11\xE\x11\xDE\x3\x11\a\x11\xE2\n\x11\f\x11\xE\x11\xE5"+
		"\v\x11\x3\x11\x3\x11\x3\x12\x3\x12\x3\x12\x3\x12\x3\x13\x3\x13\x3\x13"+
		"\x3\x13\x3\x14\x3\x14\x3\x14\a\x14\xF4\n\x14\f\x14\xE\x14\xF7\v\x14\x3"+
		"\x15\x3\x15\x3\x15\x3\x15\x3\x16\x3\x16\x3\x16\x3\x16\x5\x16\x101\n\x16"+
		"\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17"+
		"\x5\x17\x10D\n\x17\x3\x17\x3\x17\x5\x17\x111\n\x17\x3\x17\x3\x17\x3\x17"+
		"\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17"+
		"\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\a\x17\x125\n\x17\f\x17\xE\x17\x128"+
		"\v\x17\x3\x18\x3\x18\x3\x18\x3\x18\x5\x18\x12E\n\x18\x3\x19\x3\x19\x3"+
		"\x1A\x3\x1A\x3\x1A\x3\x1A\x5\x1A\x136\n\x1A\x3\x1B\x3\x1B\x5\x1B\x13A"+
		"\n\x1B\x3\x1B\x2\x2\x3,\x1C\x2\x2\x4\x2\x6\x2\b\x2\n\x2\f\x2\xE\x2\x10"+
		"\x2\x12\x2\x14\x2\x16\x2\x18\x2\x1A\x2\x1C\x2\x1E\x2 \x2\"\x2$\x2&\x2"+
		"(\x2*\x2,\x2.\x2\x30\x2\x32\x2\x34\x2\x2\a\x4\x2..\x39:\x3\x2;<\x3\x2"+
		"\x39:\x3\x2\x33\x38\x3\x2\x1E!\x14F\x2\x36\x3\x2\x2\x2\x4>\x3\x2\x2\x2"+
		"\x6J\x3\x2\x2\x2\b]\x3\x2\x2\x2\nq\x3\x2\x2\x2\f\x83\x3\x2\x2\x2\xE\x87"+
		"\x3\x2\x2\x2\x10\x9D\x3\x2\x2\x2\x12\x9F\x3\x2\x2\x2\x14\xA7\x3\x2\x2"+
		"\x2\x16\xBB\x3\x2\x2\x2\x18\xC0\x3\x2\x2\x2\x1A\xC3\x3\x2\x2\x2\x1C\xC8"+
		"\x3\x2\x2\x2\x1E\xCE\x3\x2\x2\x2 \xD9\x3\x2\x2\x2\"\xE8\x3\x2\x2\x2$\xEC"+
		"\x3\x2\x2\x2&\xF0\x3\x2\x2\x2(\xF8\x3\x2\x2\x2*\x100\x3\x2\x2\x2,\x110"+
		"\x3\x2\x2\x2.\x12D\x3\x2\x2\x2\x30\x12F\x3\x2\x2\x2\x32\x135\x3\x2\x2"+
		"\x2\x34\x139\x3\x2\x2\x2\x36;\x5\x4\x3\x2\x37:\x5\x6\x4\x2\x38:\x5\b\x5"+
		"\x2\x39\x37\x3\x2\x2\x2\x39\x38\x3\x2\x2\x2:=\x3\x2\x2\x2;\x39\x3\x2\x2"+
		"\x2;<\x3\x2\x2\x2<\x3\x3\x2\x2\x2=;\x3\x2\x2\x2>?\a\x4\x2\x2?\x43\a\x32"+
		"\x2\x2@\x42\x5\xE\b\x2\x41@\x3\x2\x2\x2\x42\x45\x3\x2\x2\x2\x43\x41\x3"+
		"\x2\x2\x2\x43\x44\x3\x2\x2\x2\x44\x46\x3\x2\x2\x2\x45\x43\x3\x2\x2\x2"+
		"\x46G\a\x5\x2\x2GH\x5\n\x6\x2HI\a\x6\x2\x2I\x5\x3\x2\x2\x2JK\a\a\x2\x2"+
		"KL\a\x32\x2\x2LN\a\x41\x2\x2MO\x5&\x14\x2NM\x3\x2\x2\x2NO\x3\x2\x2\x2"+
		"OP\x3\x2\x2\x2PQ\a\x42\x2\x2QR\a\x3\x2\x2RV\x5\x30\x19\x2SU\x5\xE\b\x2"+
		"TS\x3\x2\x2\x2UX\x3\x2\x2\x2VT\x3\x2\x2\x2VW\x3\x2\x2\x2WY\x3\x2\x2\x2"+
		"XV\x3\x2\x2\x2YZ\a\x5\x2\x2Z[\x5\n\x6\x2[\\\a\b\x2\x2\\\a\x3\x2\x2\x2"+
		"]^\a\t\x2\x2^_\a\x32\x2\x2_\x61\a\x41\x2\x2`\x62\x5&\x14\x2\x61`\x3\x2"+
		"\x2\x2\x61\x62\x3\x2\x2\x2\x62\x63\x3\x2\x2\x2\x63g\a\x42\x2\x2\x64\x66"+
		"\x5\xE\b\x2\x65\x64\x3\x2\x2\x2\x66i\x3\x2\x2\x2g\x65\x3\x2\x2\x2gh\x3"+
		"\x2\x2\x2hj\x3\x2\x2\x2ig\x3\x2\x2\x2jk\a\x5\x2\x2kl\x5\n\x6\x2lm\a\n"+
		"\x2\x2m\t\x3\x2\x2\x2np\x5\f\a\x2on\x3\x2\x2\x2ps\x3\x2\x2\x2qo\x3\x2"+
		"\x2\x2qr\x3\x2\x2\x2r\v\x3\x2\x2\x2sq\x3\x2\x2\x2t\x84\x5,\x17\x2u\x84"+
		"\x5(\x15\x2vw\x5\x32\x1A\x2w|\x5,\x17\x2xy\a?\x2\x2y{\x5,\x17\x2zx\x3"+
		"\x2\x2\x2{~\x3\x2\x2\x2|z\x3\x2\x2\x2|}\x3\x2\x2\x2}\x84\x3\x2\x2\x2~"+
		"|\x3\x2\x2\x2\x7F\x84\x5\x14\v\x2\x80\x84\x5\x1A\xE\x2\x81\x84\x5\x1C"+
		"\xF\x2\x82\x84\x5 \x11\x2\x83t\x3\x2\x2\x2\x83u\x3\x2\x2\x2\x83v\x3\x2"+
		"\x2\x2\x83\x7F\x3\x2\x2\x2\x83\x80\x3\x2\x2\x2\x83\x81\x3\x2\x2\x2\x83"+
		"\x82\x3\x2\x2\x2\x84\r\x3\x2\x2\x2\x85\x88\x5\x10\t\x2\x86\x88\x5\x12"+
		"\n\x2\x87\x85\x3\x2\x2\x2\x87\x86\x3\x2\x2\x2\x88\xF\x3\x2\x2\x2\x89\x8A"+
		"\a\v\x2\x2\x8A\x8B\x5.\x18\x2\x8B\x8C\a\x3\x2\x2\x8C\x91\a\x32\x2\x2\x8D"+
		"\x8E\a?\x2\x2\x8E\x90\a\x32\x2\x2\x8F\x8D\x3\x2\x2\x2\x90\x93\x3\x2\x2"+
		"\x2\x91\x8F\x3\x2\x2\x2\x91\x92\x3\x2\x2\x2\x92\x9E\x3\x2\x2\x2\x93\x91"+
		"\x3\x2\x2\x2\x94\x99\a\v\x2\x2\x95\x96\x5.\x18\x2\x96\x97\a\x3\x2\x2\x97"+
		"\x98\a\x32\x2\x2\x98\x9A\x3\x2\x2\x2\x99\x95\x3\x2\x2\x2\x9A\x9B\x3\x2"+
		"\x2\x2\x9B\x99\x3\x2\x2\x2\x9B\x9C\x3\x2\x2\x2\x9C\x9E\x3\x2\x2\x2\x9D"+
		"\x89\x3\x2\x2\x2\x9D\x94\x3\x2\x2\x2\x9E\x11\x3\x2\x2\x2\x9F\xA3\a\f\x2"+
		"\x2\xA0\xA1\a\x32\x2\x2\xA1\xA2\a\x33\x2\x2\xA2\xA4\x5*\x16\x2\xA3\xA0"+
		"\x3\x2\x2\x2\xA4\xA5\x3\x2\x2\x2\xA5\xA3\x3\x2\x2\x2\xA5\xA6\x3\x2\x2"+
		"\x2\xA6\x13\x3\x2\x2\x2\xA7\xA8\a\r\x2\x2\xA8\xA9\x5,\x17\x2\xA9\xAD\a"+
		"\xE\x2\x2\xAA\xAC\x5\f\a\x2\xAB\xAA\x3\x2\x2\x2\xAC\xAF\x3\x2\x2\x2\xAD"+
		"\xAB\x3\x2\x2\x2\xAD\xAE\x3\x2\x2\x2\xAE\xB3\x3\x2\x2\x2\xAF\xAD\x3\x2"+
		"\x2\x2\xB0\xB2\x5\x16\f\x2\xB1\xB0\x3\x2\x2\x2\xB2\xB5\x3\x2\x2\x2\xB3"+
		"\xB1\x3\x2\x2\x2\xB3\xB4\x3\x2\x2\x2\xB4\xB7\x3\x2\x2\x2\xB5\xB3\x3\x2"+
		"\x2\x2\xB6\xB8\x5\x18\r\x2\xB7\xB6\x3\x2\x2\x2\xB7\xB8\x3\x2\x2\x2\xB8"+
		"\xB9\x3\x2\x2\x2\xB9\xBA\a\xF\x2\x2\xBA\x15\x3\x2\x2\x2\xBB\xBC\a\x10"+
		"\x2\x2\xBC\xBD\x5,\x17\x2\xBD\xBE\a\xE\x2\x2\xBE\xBF\x5\n\x6\x2\xBF\x17"+
		"\x3\x2\x2\x2\xC0\xC1\a\x11\x2\x2\xC1\xC2\x5\n\x6\x2\xC2\x19\x3\x2\x2\x2"+
		"\xC3\xC4\a\x12\x2\x2\xC4\xC5\x5\n\x6\x2\xC5\xC6\a\x13\x2\x2\xC6\xC7\x5"+
		",\x17\x2\xC7\x1B\x3\x2\x2\x2\xC8\xC9\a\x14\x2\x2\xC9\xCA\x5,\x17\x2\xCA"+
		"\xCB\a\x15\x2\x2\xCB\xCC\x5\n\x6\x2\xCC\xCD\a\x16\x2\x2\xCD\x1D\x3\x2"+
		"\x2\x2\xCE\xCF\a\x17\x2\x2\xCF\xD0\a\x32\x2\x2\xD0\xD1\a\x18\x2\x2\xD1"+
		"\xD2\a/\x2\x2\xD2\xD3\a\x19\x2\x2\xD3\xD4\a/\x2\x2\xD4\xD5\a\x1A\x2\x2"+
		"\xD5\xD6\x5,\x17\x2\xD6\xD7\x5\n\x6\x2\xD7\xD8\a\x16\x2\x2\xD8\x1F\x3"+
		"\x2\x2\x2\xD9\xDA\a\x1B\x2\x2\xDA\xDC\a\x32\x2\x2\xDB\xDD\x5\"\x12\x2"+
		"\xDC\xDB\x3\x2\x2\x2\xDD\xDE\x3\x2\x2\x2\xDE\xDC\x3\x2\x2\x2\xDE\xDF\x3"+
		"\x2\x2\x2\xDF\xE3\x3\x2\x2\x2\xE0\xE2\x5$\x13\x2\xE1\xE0\x3\x2\x2\x2\xE2"+
		"\xE5\x3\x2\x2\x2\xE3\xE1\x3\x2\x2\x2\xE3\xE4\x3\x2\x2\x2\xE4\xE6\x3\x2"+
		"\x2\x2\xE5\xE3\x3\x2\x2\x2\xE6\xE7\a\x1D\x2\x2\xE7!\x3\x2\x2\x2\xE8\xE9"+
		"\a\x1C\x2\x2\xE9\xEA\x5,\x17\x2\xEA\xEB\x5\n\x6\x2\xEB#\x3\x2\x2\x2\xEC"+
		"\xED\a\x1C\x2\x2\xED\xEE\a\x11\x2\x2\xEE\xEF\x5\n\x6\x2\xEF%\x3\x2\x2"+
		"\x2\xF0\xF5\x5*\x16\x2\xF1\xF2\a?\x2\x2\xF2\xF4\x5*\x16\x2\xF3\xF1\x3"+
		"\x2\x2\x2\xF4\xF7\x3\x2\x2\x2\xF5\xF3\x3\x2\x2\x2\xF5\xF6\x3\x2\x2\x2"+
		"\xF6\'\x3\x2\x2\x2\xF7\xF5\x3\x2\x2\x2\xF8\xF9\a\x32\x2\x2\xF9\xFA\a@"+
		"\x2\x2\xFA\xFB\x5,\x17\x2\xFB)\x3\x2\x2\x2\xFC\x101\a/\x2\x2\xFD\x101"+
		"\a\x30\x2\x2\xFE\x101\a\x31\x2\x2\xFF\x101\a\x32\x2\x2\x100\xFC\x3\x2"+
		"\x2\x2\x100\xFD\x3\x2\x2\x2\x100\xFE\x3\x2\x2\x2\x100\xFF\x3\x2\x2\x2"+
		"\x101+\x3\x2\x2\x2\x102\x103\b\x17\x1\x2\x103\x104\t\x2\x2\x2\x104\x111"+
		"\x5,\x17\n\x105\x106\a\x41\x2\x2\x106\x107\x5,\x17\x2\x107\x108\a\x42"+
		"\x2\x2\x108\x111\x3\x2\x2\x2\x109\x10A\a\x32\x2\x2\x10A\x10C\a\x41\x2"+
		"\x2\x10B\x10D\x5&\x14\x2\x10C\x10B\x3\x2\x2\x2\x10C\x10D\x3\x2\x2\x2\x10D"+
		"\x10E\x3\x2\x2\x2\x10E\x111\a\x42\x2\x2\x10F\x111\x5*\x16\x2\x110\x102"+
		"\x3\x2\x2\x2\x110\x105\x3\x2\x2\x2\x110\x109\x3\x2\x2\x2\x110\x10F\x3"+
		"\x2\x2\x2\x111\x126\x3\x2\x2\x2\x112\x113\f\v\x2\x2\x113\x114\a=\x2\x2"+
		"\x114\x125\x5,\x17\v\x115\x116\f\t\x2\x2\x116\x117\t\x3\x2\x2\x117\x125"+
		"\x5,\x17\n\x118\x119\f\b\x2\x2\x119\x11A\t\x4\x2\x2\x11A\x125\x5,\x17"+
		"\t\x11B\x11C\f\a\x2\x2\x11C\x11D\t\x5\x2\x2\x11D\x125\x5,\x17\b\x11E\x11F"+
		"\f\x6\x2\x2\x11F\x120\a,\x2\x2\x120\x125\x5,\x17\a\x121\x122\f\x5\x2\x2"+
		"\x122\x123\a-\x2\x2\x123\x125\x5,\x17\x6\x124\x112\x3\x2\x2\x2\x124\x115"+
		"\x3\x2\x2\x2\x124\x118\x3\x2\x2\x2\x124\x11B\x3\x2\x2\x2\x124\x11E\x3"+
		"\x2\x2\x2\x124\x121\x3\x2\x2\x2\x125\x128\x3\x2\x2\x2\x126\x124\x3\x2"+
		"\x2\x2\x126\x127\x3\x2\x2\x2\x127-\x3\x2\x2\x2\x128\x126\x3\x2\x2\x2\x129"+
		"\x12E\a\"\x2\x2\x12A\x12E\a#\x2\x2\x12B\x12E\a$\x2\x2\x12C\x12E\a%\x2"+
		"\x2\x12D\x129\x3\x2\x2\x2\x12D\x12A\x3\x2\x2\x2\x12D\x12B\x3\x2\x2\x2"+
		"\x12D\x12C\x3\x2\x2\x2\x12E/\x3\x2\x2\x2\x12F\x130\t\x6\x2\x2\x130\x31"+
		"\x3\x2\x2\x2\x131\x136\a&\x2\x2\x132\x136\a\'\x2\x2\x133\x136\a(\x2\x2"+
		"\x134\x136\a)\x2\x2\x135\x131\x3\x2\x2\x2\x135\x132\x3\x2\x2\x2\x135\x133"+
		"\x3\x2\x2\x2\x135\x134\x3\x2\x2\x2\x136\x33\x3\x2\x2\x2\x137\x13A\a*\x2"+
		"\x2\x138\x13A\a+\x2\x2\x139\x137\x3\x2\x2\x2\x139\x138\x3\x2\x2\x2\x13A"+
		"\x35\x3\x2\x2\x2\x1F\x39;\x43NV\x61gq|\x83\x87\x91\x9B\x9D\xA5\xAD\xB3"+
		"\xB7\xDE\xE3\xF5\x100\x10C\x110\x124\x126\x12D\x135\x139";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace Glossa
