//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.4.1-SNAPSHOT
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:\Users\Sonic\Documents\Visual Studio 2013\Projects\Glossa\Glossa\GLOSSA.g4 by ANTLR 4.4.1-SNAPSHOT

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591

namespace Glossa {
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.4.1-SNAPSHOT")]
[System.CLSCompliant(false)]
public partial class GLOSSAParser : Parser {
	public const int
		T__0=1, PROGRAMMA=2, ARXH=3, TELOS_PROGRAMMATOS=4, SYNARTHSH=5, TELOS_SYNARTHSHS=6, 
		DIADIKASIA=7, TELOS_DIADIKASIAS=8, METABLHTES=9, STATHERES=10, AN=11, 
		TOTE=12, TELOS_AN=13, ALLIOS_AN=14, ALLIOS=15, ARXH_EPANALIPSIS=16, MEXRIS_OTOU=17, 
		OSO=18, EPANALABE=19, TELOS_EPANALIPSIS=20, GIA=21, APO=22, MEXRI=23, 
		ME_BHMA=24, EPILEKSE=25, PERIPTOSI=26, TELOS_EPILOGON=27, AKERAIA=28, 
		AKERAIES=29, PRAGMATIKES=30, XARAKTHRES=31, LOGIKES=32, GRAPSE=33, EKTIPOSE=34, 
		DIABASE=35, KALESE=36, TRUE=37, FALSE=38, KAI=39, H=40, OXI=41, INTEGER=42, 
		DECIMAL=43, STRING=44, IDENTIFIER=45, EQUALS=46, NOTEQUALS=47, GT=48, 
		GE=49, LT=50, LE=51, PLUS=52, MINUS=53, MUL=54, DIV=55, POWER=56, SEMICOLON=57, 
		COMMA=58, ASSIGNMENT=59, LPAREN=60, RPAREN=61, LBRACKET=62, RBRACKET=63, 
		LANCHOR=64, RANCHOR=65, COMMENTS=66, WS=67;
	public const int
		RULE_file = 0, RULE_program = 1, RULE_functiondefinition = 2, RULE_proceduredefinition = 3, 
		RULE_statementlist = 4, RULE_statement = 5, RULE_declarations = 6, RULE_variabledeclarations = 7, 
		RULE_constantdeclarations = 8, RULE_ifcontrol = 9, RULE_elseif = 10, RULE_else = 11, 
		RULE_dowhileloop = 12, RULE_whileloop = 13, RULE_forloop = 14, RULE_switchcontrol = 15, 
		RULE_casescontrol = 16, RULE_otherwisecontrol = 17, RULE_functionarguments = 18, 
		RULE_assignment = 19, RULE_expressionprimitives = 20, RULE_expression = 21, 
		RULE_type = 22, RULE_keyword = 23, RULE_bool = 24;
	public static readonly string[] ruleNames = {
		"file", "program", "functiondefinition", "proceduredefinition", "statementlist", 
		"statement", "declarations", "variabledeclarations", "constantdeclarations", 
		"ifcontrol", "elseif", "else", "dowhileloop", "whileloop", "forloop", 
		"switchcontrol", "casescontrol", "otherwisecontrol", "functionarguments", 
		"assignment", "expressionprimitives", "expression", "type", "keyword", 
		"bool"
	};

	private static readonly string[] _LiteralNames = {
		null, "':'", "'пяоцяалла'", "'аявг'", "'текос_пяоцяаллатос'", "'сумаятгсг'", 
		"'текос_сумаятгсгс'", "'диадийасиа'", "'текос_диадийасиас'", "'летабкгтес'", 
		"'стахеяес'", "'ам'", "'тоте'", "'текос_ам'", "'аккиыс_ам'", "'аккиыс'", 
		"'аявг_епамакгьгс'", "'левяис_отоу'", "'осо'", "'епамакабе'", "'текос_епамакгьгс'", 
		"'циа'", "'апо'", "'левяи'", "'ле_бгла'", "'епикене'", "'пеяиптысг'", 
		"'текос_епикоцым'", "'айеяаиа'", "'айеяаиес'", "'пяацлатийес'", "'ваяайтгяес'", 
		"'коцийес'", "'цяаье'", "'ейтупысе'", "'диабасе'", "'йакесе'", "'акгхгс'", 
		"'ьеудгс'", "'йаи'", "'г'", "'ови'", null, null, null, null, "'='", "'<>'", 
		"'>'", "'>='", "'<'", "'<='", "'+'", "'-'", "'*'", "'/'", "'^'", "';'", 
		"','", "'<-'", "'('", "')'", "'['", "']'", "'{'", "'}'"
	};
	private static readonly string[] _SymbolicNames = {
		null, null, "PROGRAMMA", "ARXH", "TELOS_PROGRAMMATOS", "SYNARTHSH", "TELOS_SYNARTHSHS", 
		"DIADIKASIA", "TELOS_DIADIKASIAS", "METABLHTES", "STATHERES", "AN", "TOTE", 
		"TELOS_AN", "ALLIOS_AN", "ALLIOS", "ARXH_EPANALIPSIS", "MEXRIS_OTOU", 
		"OSO", "EPANALABE", "TELOS_EPANALIPSIS", "GIA", "APO", "MEXRI", "ME_BHMA", 
		"EPILEKSE", "PERIPTOSI", "TELOS_EPILOGON", "AKERAIA", "AKERAIES", "PRAGMATIKES", 
		"XARAKTHRES", "LOGIKES", "GRAPSE", "EKTIPOSE", "DIABASE", "KALESE", "TRUE", 
		"FALSE", "KAI", "H", "OXI", "INTEGER", "DECIMAL", "STRING", "IDENTIFIER", 
		"EQUALS", "NOTEQUALS", "GT", "GE", "LT", "LE", "PLUS", "MINUS", "MUL", 
		"DIV", "POWER", "SEMICOLON", "COMMA", "ASSIGNMENT", "LPAREN", "RPAREN", 
		"LBRACKET", "RBRACKET", "LANCHOR", "RANCHOR", "COMMENTS", "WS"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[System.Obsolete("Use Vocabulary instead.")]
	public static readonly string[] tokenNames = GenerateTokenNames(DefaultVocabulary, _SymbolicNames.Length);

	private static string[] GenerateTokenNames(IVocabulary vocabulary, int length) {
		string[] tokenNames = new string[length];
		for (int i = 0; i < tokenNames.Length; i++) {
			tokenNames[i] = vocabulary.GetLiteralName(i);
			if (tokenNames[i] == null) {
				tokenNames[i] = vocabulary.GetSymbolicName(i);
			}

			if (tokenNames[i] == null) {
				tokenNames[i] = "<INVALID>";
			}
		}

		return tokenNames;
	}

	[System.Obsolete]
	public override string[] TokenNames
	{
		get
		{
			return tokenNames;
		}
	}

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "GLOSSA.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public GLOSSAParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class FileContext : ParserRuleContext {
		public FileContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_file; } }
	 
		public FileContext() { }
		public virtual void CopyFrom(FileContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class FilestartContext : FileContext {
		public IReadOnlyList<FunctiondefinitionContext> functiondefinition() {
			return GetRuleContexts<FunctiondefinitionContext>();
		}
		public ProgramContext program() {
			return GetRuleContext<ProgramContext>(0);
		}
		public FunctiondefinitionContext functiondefinition(int i) {
			return GetRuleContext<FunctiondefinitionContext>(i);
		}
		public IReadOnlyList<ProceduredefinitionContext> proceduredefinition() {
			return GetRuleContexts<ProceduredefinitionContext>();
		}
		public ProceduredefinitionContext proceduredefinition(int i) {
			return GetRuleContext<ProceduredefinitionContext>(i);
		}
		public FilestartContext(FileContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterFilestart(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitFilestart(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFilestart(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FileContext file() {
		FileContext _localctx = new FileContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_file);
		int _la;
		try {
			_localctx = new FilestartContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 50; program();
			State = 55;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==SYNARTHSH || _la==DIADIKASIA) {
				{
				State = 53;
				switch (_input.La(1)) {
				case SYNARTHSH:
					{
					State = 51; functiondefinition();
					}
					break;
				case DIADIKASIA:
					{
					State = 52; proceduredefinition();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 57;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProgramContext : ParserRuleContext {
		public ProgramContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_program; } }
	 
		public ProgramContext() { }
		public virtual void CopyFrom(ProgramContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ProgramstartContext : ProgramContext {
		public DeclarationsContext declarations(int i) {
			return GetRuleContext<DeclarationsContext>(i);
		}
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public ITerminalNode TELOS_PROGRAMMATOS() { return GetToken(GLOSSAParser.TELOS_PROGRAMMATOS, 0); }
		public IReadOnlyList<DeclarationsContext> declarations() {
			return GetRuleContexts<DeclarationsContext>();
		}
		public ITerminalNode ARXH() { return GetToken(GLOSSAParser.ARXH, 0); }
		public ITerminalNode PROGRAMMA() { return GetToken(GLOSSAParser.PROGRAMMA, 0); }
		public ITerminalNode IDENTIFIER() { return GetToken(GLOSSAParser.IDENTIFIER, 0); }
		public ProgramstartContext(ProgramContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterProgramstart(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitProgramstart(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProgramstart(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ProgramContext program() {
		ProgramContext _localctx = new ProgramContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_program);
		int _la;
		try {
			_localctx = new ProgramstartContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 58; Match(PROGRAMMA);
			State = 59; Match(IDENTIFIER);
			State = 63;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==METABLHTES || _la==STATHERES) {
				{
				{
				State = 60; declarations();
				}
				}
				State = 65;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 66; Match(ARXH);
			State = 67; statementlist();
			State = 68; Match(TELOS_PROGRAMMATOS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctiondefinitionContext : ParserRuleContext {
		public FunctiondefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functiondefinition; } }
	 
		public FunctiondefinitionContext() { }
		public virtual void CopyFrom(FunctiondefinitionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class FuncdefContext : FunctiondefinitionContext {
		public DeclarationsContext declarations(int i) {
			return GetRuleContext<DeclarationsContext>(i);
		}
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public FunctionargumentsContext functionarguments() {
			return GetRuleContext<FunctionargumentsContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(GLOSSAParser.LPAREN, 0); }
		public ITerminalNode SYNARTHSH() { return GetToken(GLOSSAParser.SYNARTHSH, 0); }
		public IReadOnlyList<DeclarationsContext> declarations() {
			return GetRuleContexts<DeclarationsContext>();
		}
		public ITerminalNode ARXH() { return GetToken(GLOSSAParser.ARXH, 0); }
		public ITerminalNode RPAREN() { return GetToken(GLOSSAParser.RPAREN, 0); }
		public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public ITerminalNode IDENTIFIER() { return GetToken(GLOSSAParser.IDENTIFIER, 0); }
		public ITerminalNode TELOS_SYNARTHSHS() { return GetToken(GLOSSAParser.TELOS_SYNARTHSHS, 0); }
		public FuncdefContext(FunctiondefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterFuncdef(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitFuncdef(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFuncdef(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctiondefinitionContext functiondefinition() {
		FunctiondefinitionContext _localctx = new FunctiondefinitionContext(_ctx, State);
		EnterRule(_localctx, 4, RULE_functiondefinition);
		int _la;
		try {
			_localctx = new FuncdefContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 70; Match(SYNARTHSH);
			State = 71; Match(IDENTIFIER);
			State = 72; Match(LPAREN);
			State = 74;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << INTEGER) | (1L << DECIMAL) | (1L << STRING) | (1L << IDENTIFIER))) != 0)) {
				{
				State = 73; functionarguments();
				}
			}

			State = 76; Match(RPAREN);
			State = 77; Match(T__0);
			State = 78; type();
			State = 82;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==METABLHTES || _la==STATHERES) {
				{
				{
				State = 79; declarations();
				}
				}
				State = 84;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 85; Match(ARXH);
			State = 86; statementlist();
			State = 87; Match(TELOS_SYNARTHSHS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProceduredefinitionContext : ParserRuleContext {
		public ProceduredefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_proceduredefinition; } }
	 
		public ProceduredefinitionContext() { }
		public virtual void CopyFrom(ProceduredefinitionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ProcdefContext : ProceduredefinitionContext {
		public DeclarationsContext declarations(int i) {
			return GetRuleContext<DeclarationsContext>(i);
		}
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public FunctionargumentsContext functionarguments() {
			return GetRuleContext<FunctionargumentsContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(GLOSSAParser.LPAREN, 0); }
		public IReadOnlyList<DeclarationsContext> declarations() {
			return GetRuleContexts<DeclarationsContext>();
		}
		public ITerminalNode ARXH() { return GetToken(GLOSSAParser.ARXH, 0); }
		public ITerminalNode RPAREN() { return GetToken(GLOSSAParser.RPAREN, 0); }
		public ITerminalNode TELOS_DIADIKASIAS() { return GetToken(GLOSSAParser.TELOS_DIADIKASIAS, 0); }
		public ITerminalNode DIADIKASIA() { return GetToken(GLOSSAParser.DIADIKASIA, 0); }
		public ITerminalNode IDENTIFIER() { return GetToken(GLOSSAParser.IDENTIFIER, 0); }
		public ProcdefContext(ProceduredefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterProcdef(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitProcdef(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProcdef(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ProceduredefinitionContext proceduredefinition() {
		ProceduredefinitionContext _localctx = new ProceduredefinitionContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_proceduredefinition);
		int _la;
		try {
			_localctx = new ProcdefContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 89; Match(DIADIKASIA);
			State = 90; Match(IDENTIFIER);
			State = 91; Match(LPAREN);
			State = 93;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << INTEGER) | (1L << DECIMAL) | (1L << STRING) | (1L << IDENTIFIER))) != 0)) {
				{
				State = 92; functionarguments();
				}
			}

			State = 95; Match(RPAREN);
			State = 99;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==METABLHTES || _la==STATHERES) {
				{
				{
				State = 96; declarations();
				}
				}
				State = 101;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 102; Match(ARXH);
			State = 103; statementlist();
			State = 104; Match(TELOS_DIADIKASIAS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementlistContext : ParserRuleContext {
		public StatementlistContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statementlist; } }
	 
		public StatementlistContext() { }
		public virtual void CopyFrom(StatementlistContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class StmtlistContext : StatementlistContext {
		public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public IReadOnlyList<StatementContext> statement() {
			return GetRuleContexts<StatementContext>();
		}
		public StmtlistContext(StatementlistContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterStmtlist(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitStmtlist(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStmtlist(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementlistContext statementlist() {
		StatementlistContext _localctx = new StatementlistContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_statementlist);
		int _la;
		try {
			_localctx = new StmtlistContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 109;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AN) | (1L << ARXH_EPANALIPSIS) | (1L << OSO) | (1L << EPILEKSE) | (1L << GRAPSE) | (1L << EKTIPOSE) | (1L << DIABASE) | (1L << KALESE) | (1L << OXI) | (1L << INTEGER) | (1L << DECIMAL) | (1L << STRING) | (1L << IDENTIFIER) | (1L << PLUS) | (1L << MINUS) | (1L << LPAREN))) != 0)) {
				{
				{
				State = 106; statement();
				}
				}
				State = 111;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
	 
		public StatementContext() { }
		public virtual void CopyFrom(StatementContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Stat_ifctrlContext : StatementContext {
		public IfcontrolContext ifcontrol() {
			return GetRuleContext<IfcontrolContext>(0);
		}
		public Stat_ifctrlContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterStat_ifctrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitStat_ifctrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStat_ifctrl(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Stat_dowhileContext : StatementContext {
		public DowhileloopContext dowhileloop() {
			return GetRuleContext<DowhileloopContext>(0);
		}
		public Stat_dowhileContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterStat_dowhile(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitStat_dowhile(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStat_dowhile(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Stat_ioexprContext : StatementContext {
		public IReadOnlyList<ITerminalNode> COMMA() { return GetTokens(GLOSSAParser.COMMA); }
		public KeywordContext keyword() {
			return GetRuleContext<KeywordContext>(0);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode COMMA(int i) {
			return GetToken(GLOSSAParser.COMMA, i);
		}
		public Stat_ioexprContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterStat_ioexpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitStat_ioexpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStat_ioexpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Stat_assignmentContext : StatementContext {
		public AssignmentContext assignment() {
			return GetRuleContext<AssignmentContext>(0);
		}
		public Stat_assignmentContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterStat_assignment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitStat_assignment(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStat_assignment(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Stat_whileContext : StatementContext {
		public WhileloopContext whileloop() {
			return GetRuleContext<WhileloopContext>(0);
		}
		public Stat_whileContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterStat_while(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitStat_while(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStat_while(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Stat_switchContext : StatementContext {
		public SwitchcontrolContext switchcontrol() {
			return GetRuleContext<SwitchcontrolContext>(0);
		}
		public Stat_switchContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterStat_switch(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitStat_switch(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStat_switch(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Stat_exprContext : StatementContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Stat_exprContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterStat_expr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitStat_expr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStat_expr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(_ctx, State);
		EnterRule(_localctx, 10, RULE_statement);
		int _la;
		try {
			State = 127;
			switch ( Interpreter.AdaptivePredict(_input,9,_ctx) ) {
			case 1:
				_localctx = new Stat_exprContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 112; expression(0);
				}
				break;

			case 2:
				_localctx = new Stat_assignmentContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 113; assignment();
				}
				break;

			case 3:
				_localctx = new Stat_ioexprContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 114; keyword();
				State = 115; expression(0);
				State = 120;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 116; Match(COMMA);
					State = 117; expression(0);
					}
					}
					State = 122;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
				break;

			case 4:
				_localctx = new Stat_ifctrlContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 123; ifcontrol();
				}
				break;

			case 5:
				_localctx = new Stat_dowhileContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 124; dowhileloop();
				}
				break;

			case 6:
				_localctx = new Stat_whileContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 125; whileloop();
				}
				break;

			case 7:
				_localctx = new Stat_switchContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 126; switchcontrol();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclarationsContext : ParserRuleContext {
		public DeclarationsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declarations; } }
	 
		public DeclarationsContext() { }
		public virtual void CopyFrom(DeclarationsContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ConstdeclContext : DeclarationsContext {
		public ConstantdeclarationsContext constantdeclarations() {
			return GetRuleContext<ConstantdeclarationsContext>(0);
		}
		public ConstdeclContext(DeclarationsContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterConstdecl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitConstdecl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstdecl(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class VardeclContext : DeclarationsContext {
		public VariabledeclarationsContext variabledeclarations() {
			return GetRuleContext<VariabledeclarationsContext>(0);
		}
		public VardeclContext(DeclarationsContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterVardecl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitVardecl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVardecl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclarationsContext declarations() {
		DeclarationsContext _localctx = new DeclarationsContext(_ctx, State);
		EnterRule(_localctx, 12, RULE_declarations);
		try {
			State = 131;
			switch (_input.La(1)) {
			case METABLHTES:
				_localctx = new VardeclContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 129; variabledeclarations();
				}
				break;
			case STATHERES:
				_localctx = new ConstdeclContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 130; constantdeclarations();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VariabledeclarationsContext : ParserRuleContext {
		public VariabledeclarationsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variabledeclarations; } }
	 
		public VariabledeclarationsContext() { }
		public virtual void CopyFrom(VariabledeclarationsContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Vardecl_alt2Context : VariabledeclarationsContext {
		public TypeContext type(int i) {
			return GetRuleContext<TypeContext>(i);
		}
		public ITerminalNode IDENTIFIER(int i) {
			return GetToken(GLOSSAParser.IDENTIFIER, i);
		}
		public IReadOnlyList<TypeContext> type() {
			return GetRuleContexts<TypeContext>();
		}
		public ITerminalNode METABLHTES() { return GetToken(GLOSSAParser.METABLHTES, 0); }
		public IReadOnlyList<ITerminalNode> IDENTIFIER() { return GetTokens(GLOSSAParser.IDENTIFIER); }
		public Vardecl_alt2Context(VariabledeclarationsContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterVardecl_alt2(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitVardecl_alt2(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVardecl_alt2(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Vardecl_alt1Context : VariabledeclarationsContext {
		public ITerminalNode IDENTIFIER(int i) {
			return GetToken(GLOSSAParser.IDENTIFIER, i);
		}
		public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public ITerminalNode METABLHTES() { return GetToken(GLOSSAParser.METABLHTES, 0); }
		public IReadOnlyList<ITerminalNode> IDENTIFIER() { return GetTokens(GLOSSAParser.IDENTIFIER); }
		public Vardecl_alt1Context(VariabledeclarationsContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterVardecl_alt1(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitVardecl_alt1(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVardecl_alt1(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VariabledeclarationsContext variabledeclarations() {
		VariabledeclarationsContext _localctx = new VariabledeclarationsContext(_ctx, State);
		EnterRule(_localctx, 14, RULE_variabledeclarations);
		int _la;
		try {
			State = 153;
			switch ( Interpreter.AdaptivePredict(_input,13,_ctx) ) {
			case 1:
				_localctx = new Vardecl_alt1Context(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 133; Match(METABLHTES);
				State = 134; type();
				State = 135; Match(T__0);
				State = 136; Match(IDENTIFIER);
				State = 141;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 137; Match(COMMA);
					State = 138; Match(IDENTIFIER);
					}
					}
					State = 143;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
				break;

			case 2:
				_localctx = new Vardecl_alt2Context(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 144; Match(METABLHTES);
				State = 149;
				_errHandler.Sync(this);
				_la = _input.La(1);
				do {
					{
					{
					State = 145; type();
					State = 146; Match(T__0);
					State = 147; Match(IDENTIFIER);
					}
					}
					State = 151;
					_errHandler.Sync(this);
					_la = _input.La(1);
				} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AKERAIA) | (1L << AKERAIES) | (1L << PRAGMATIKES) | (1L << XARAKTHRES) | (1L << LOGIKES))) != 0) );
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstantdeclarationsContext : ParserRuleContext {
		public ConstantdeclarationsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constantdeclarations; } }
	 
		public ConstantdeclarationsContext() { }
		public virtual void CopyFrom(ConstantdeclarationsContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Constdecl_altContext : ConstantdeclarationsContext {
		public IReadOnlyList<ITerminalNode> EQUALS() { return GetTokens(GLOSSAParser.EQUALS); }
		public ITerminalNode STATHERES() { return GetToken(GLOSSAParser.STATHERES, 0); }
		public ITerminalNode IDENTIFIER(int i) {
			return GetToken(GLOSSAParser.IDENTIFIER, i);
		}
		public ITerminalNode EQUALS(int i) {
			return GetToken(GLOSSAParser.EQUALS, i);
		}
		public IReadOnlyList<ITerminalNode> IDENTIFIER() { return GetTokens(GLOSSAParser.IDENTIFIER); }
		public IReadOnlyList<ExpressionprimitivesContext> expressionprimitives() {
			return GetRuleContexts<ExpressionprimitivesContext>();
		}
		public ExpressionprimitivesContext expressionprimitives(int i) {
			return GetRuleContext<ExpressionprimitivesContext>(i);
		}
		public Constdecl_altContext(ConstantdeclarationsContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterConstdecl_alt(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitConstdecl_alt(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstdecl_alt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConstantdeclarationsContext constantdeclarations() {
		ConstantdeclarationsContext _localctx = new ConstantdeclarationsContext(_ctx, State);
		EnterRule(_localctx, 16, RULE_constantdeclarations);
		int _la;
		try {
			_localctx = new Constdecl_altContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 155; Match(STATHERES);
			State = 159;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 156; Match(IDENTIFIER);
				State = 157; Match(EQUALS);
				State = 158; expressionprimitives();
				}
				}
				State = 161;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==IDENTIFIER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfcontrolContext : ParserRuleContext {
		public IfcontrolContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifcontrol; } }
	 
		public IfcontrolContext() { }
		public virtual void CopyFrom(IfcontrolContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class IfctrlContext : IfcontrolContext {
		public IReadOnlyList<ElseifContext> elseif() {
			return GetRuleContexts<ElseifContext>();
		}
		public ITerminalNode TOTE() { return GetToken(GLOSSAParser.TOTE, 0); }
		public ITerminalNode TELOS_AN() { return GetToken(GLOSSAParser.TELOS_AN, 0); }
		public ITerminalNode AN() { return GetToken(GLOSSAParser.AN, 0); }
		public ElseContext @else() {
			return GetRuleContext<ElseContext>(0);
		}
		public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public ElseifContext elseif(int i) {
			return GetRuleContext<ElseifContext>(i);
		}
		public IReadOnlyList<StatementContext> statement() {
			return GetRuleContexts<StatementContext>();
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public IfctrlContext(IfcontrolContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterIfctrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitIfctrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfctrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IfcontrolContext ifcontrol() {
		IfcontrolContext _localctx = new IfcontrolContext(_ctx, State);
		EnterRule(_localctx, 18, RULE_ifcontrol);
		int _la;
		try {
			_localctx = new IfctrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 163; Match(AN);
			State = 164; expression(0);
			State = 165; Match(TOTE);
			State = 169;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AN) | (1L << ARXH_EPANALIPSIS) | (1L << OSO) | (1L << EPILEKSE) | (1L << GRAPSE) | (1L << EKTIPOSE) | (1L << DIABASE) | (1L << KALESE) | (1L << OXI) | (1L << INTEGER) | (1L << DECIMAL) | (1L << STRING) | (1L << IDENTIFIER) | (1L << PLUS) | (1L << MINUS) | (1L << LPAREN))) != 0)) {
				{
				{
				State = 166; statement();
				}
				}
				State = 171;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 175;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==ALLIOS_AN) {
				{
				{
				State = 172; elseif();
				}
				}
				State = 177;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 179;
			_la = _input.La(1);
			if (_la==ALLIOS) {
				{
				State = 178; @else();
				}
			}

			State = 181; Match(TELOS_AN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElseifContext : ParserRuleContext {
		public ElseifContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elseif; } }
	 
		public ElseifContext() { }
		public virtual void CopyFrom(ElseifContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ElseifctrlContext : ElseifContext {
		public ITerminalNode TOTE() { return GetToken(GLOSSAParser.TOTE, 0); }
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public ITerminalNode ALLIOS_AN() { return GetToken(GLOSSAParser.ALLIOS_AN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ElseifctrlContext(ElseifContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterElseifctrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitElseifctrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElseifctrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElseifContext elseif() {
		ElseifContext _localctx = new ElseifContext(_ctx, State);
		EnterRule(_localctx, 20, RULE_elseif);
		try {
			_localctx = new ElseifctrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 183; Match(ALLIOS_AN);
			State = 184; expression(0);
			State = 185; Match(TOTE);
			State = 186; statementlist();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElseContext : ParserRuleContext {
		public ElseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_else; } }
	 
		public ElseContext() { }
		public virtual void CopyFrom(ElseContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ElsectrlContext : ElseContext {
		public ITerminalNode ALLIOS() { return GetToken(GLOSSAParser.ALLIOS, 0); }
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public ElsectrlContext(ElseContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterElsectrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitElsectrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElsectrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElseContext @else() {
		ElseContext _localctx = new ElseContext(_ctx, State);
		EnterRule(_localctx, 22, RULE_else);
		try {
			_localctx = new ElsectrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 188; Match(ALLIOS);
			State = 189; statementlist();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DowhileloopContext : ParserRuleContext {
		public DowhileloopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dowhileloop; } }
	 
		public DowhileloopContext() { }
		public virtual void CopyFrom(DowhileloopContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class DowhilectrlContext : DowhileloopContext {
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public ITerminalNode MEXRIS_OTOU() { return GetToken(GLOSSAParser.MEXRIS_OTOU, 0); }
		public ITerminalNode ARXH_EPANALIPSIS() { return GetToken(GLOSSAParser.ARXH_EPANALIPSIS, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public DowhilectrlContext(DowhileloopContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterDowhilectrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitDowhilectrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDowhilectrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DowhileloopContext dowhileloop() {
		DowhileloopContext _localctx = new DowhileloopContext(_ctx, State);
		EnterRule(_localctx, 24, RULE_dowhileloop);
		try {
			_localctx = new DowhilectrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 191; Match(ARXH_EPANALIPSIS);
			State = 192; statementlist();
			State = 193; Match(MEXRIS_OTOU);
			State = 194; expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhileloopContext : ParserRuleContext {
		public WhileloopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whileloop; } }
	 
		public WhileloopContext() { }
		public virtual void CopyFrom(WhileloopContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class WhilectrlContext : WhileloopContext {
		public ITerminalNode EPANALABE() { return GetToken(GLOSSAParser.EPANALABE, 0); }
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public ITerminalNode OSO() { return GetToken(GLOSSAParser.OSO, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode TELOS_EPANALIPSIS() { return GetToken(GLOSSAParser.TELOS_EPANALIPSIS, 0); }
		public WhilectrlContext(WhileloopContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterWhilectrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitWhilectrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhilectrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WhileloopContext whileloop() {
		WhileloopContext _localctx = new WhileloopContext(_ctx, State);
		EnterRule(_localctx, 26, RULE_whileloop);
		try {
			_localctx = new WhilectrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 196; Match(OSO);
			State = 197; expression(0);
			State = 198; Match(EPANALABE);
			State = 199; statementlist();
			State = 200; Match(TELOS_EPANALIPSIS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForloopContext : ParserRuleContext {
		public ForloopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forloop; } }
	 
		public ForloopContext() { }
		public virtual void CopyFrom(ForloopContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ForctrlContext : ForloopContext {
		public ITerminalNode ME_BHMA() { return GetToken(GLOSSAParser.ME_BHMA, 0); }
		public IReadOnlyList<ITerminalNode> INTEGER() { return GetTokens(GLOSSAParser.INTEGER); }
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public ITerminalNode MEXRI() { return GetToken(GLOSSAParser.MEXRI, 0); }
		public ITerminalNode APO() { return GetToken(GLOSSAParser.APO, 0); }
		public ITerminalNode INTEGER(int i) {
			return GetToken(GLOSSAParser.INTEGER, i);
		}
		public ITerminalNode IDENTIFIER() { return GetToken(GLOSSAParser.IDENTIFIER, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode TELOS_EPANALIPSIS() { return GetToken(GLOSSAParser.TELOS_EPANALIPSIS, 0); }
		public ITerminalNode GIA() { return GetToken(GLOSSAParser.GIA, 0); }
		public ForctrlContext(ForloopContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterForctrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitForctrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitForctrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ForloopContext forloop() {
		ForloopContext _localctx = new ForloopContext(_ctx, State);
		EnterRule(_localctx, 28, RULE_forloop);
		try {
			_localctx = new ForctrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 202; Match(GIA);
			State = 203; Match(IDENTIFIER);
			State = 204; Match(APO);
			State = 205; Match(INTEGER);
			State = 206; Match(MEXRI);
			State = 207; Match(INTEGER);
			State = 208; Match(ME_BHMA);
			State = 209; expression(0);
			State = 210; statementlist();
			State = 211; Match(TELOS_EPANALIPSIS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SwitchcontrolContext : ParserRuleContext {
		public SwitchcontrolContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_switchcontrol; } }
	 
		public SwitchcontrolContext() { }
		public virtual void CopyFrom(SwitchcontrolContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class SwitchctrlContext : SwitchcontrolContext {
		public ITerminalNode EPILEKSE() { return GetToken(GLOSSAParser.EPILEKSE, 0); }
		public ITerminalNode IDENTIFIER() { return GetToken(GLOSSAParser.IDENTIFIER, 0); }
		public ITerminalNode TELOS_EPILOGON() { return GetToken(GLOSSAParser.TELOS_EPILOGON, 0); }
		public IReadOnlyList<CasescontrolContext> casescontrol() {
			return GetRuleContexts<CasescontrolContext>();
		}
		public CasescontrolContext casescontrol(int i) {
			return GetRuleContext<CasescontrolContext>(i);
		}
		public IReadOnlyList<OtherwisecontrolContext> otherwisecontrol() {
			return GetRuleContexts<OtherwisecontrolContext>();
		}
		public OtherwisecontrolContext otherwisecontrol(int i) {
			return GetRuleContext<OtherwisecontrolContext>(i);
		}
		public SwitchctrlContext(SwitchcontrolContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterSwitchctrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitSwitchctrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSwitchctrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SwitchcontrolContext switchcontrol() {
		SwitchcontrolContext _localctx = new SwitchcontrolContext(_ctx, State);
		EnterRule(_localctx, 30, RULE_switchcontrol);
		int _la;
		try {
			int _alt;
			_localctx = new SwitchctrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 213; Match(EPILEKSE);
			State = 214; Match(IDENTIFIER);
			State = 216;
			_errHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 215; casescontrol();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 218;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,18,_ctx);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber );
			State = 223;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==PERIPTOSI) {
				{
				{
				State = 220; otherwisecontrol();
				}
				}
				State = 225;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 226; Match(TELOS_EPILOGON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CasescontrolContext : ParserRuleContext {
		public CasescontrolContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_casescontrol; } }
	 
		public CasescontrolContext() { }
		public virtual void CopyFrom(CasescontrolContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class CasectrlContext : CasescontrolContext {
		public ITerminalNode PERIPTOSI() { return GetToken(GLOSSAParser.PERIPTOSI, 0); }
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public CasectrlContext(CasescontrolContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterCasectrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitCasectrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCasectrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CasescontrolContext casescontrol() {
		CasescontrolContext _localctx = new CasescontrolContext(_ctx, State);
		EnterRule(_localctx, 32, RULE_casescontrol);
		try {
			_localctx = new CasectrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 228; Match(PERIPTOSI);
			State = 229; expression(0);
			State = 230; statementlist();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OtherwisecontrolContext : ParserRuleContext {
		public OtherwisecontrolContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_otherwisecontrol; } }
	 
		public OtherwisecontrolContext() { }
		public virtual void CopyFrom(OtherwisecontrolContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class OtherwisectrlContext : OtherwisecontrolContext {
		public ITerminalNode PERIPTOSI() { return GetToken(GLOSSAParser.PERIPTOSI, 0); }
		public ITerminalNode ALLIOS() { return GetToken(GLOSSAParser.ALLIOS, 0); }
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public OtherwisectrlContext(OtherwisecontrolContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterOtherwisectrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitOtherwisectrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOtherwisectrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OtherwisecontrolContext otherwisecontrol() {
		OtherwisecontrolContext _localctx = new OtherwisecontrolContext(_ctx, State);
		EnterRule(_localctx, 34, RULE_otherwisecontrol);
		try {
			_localctx = new OtherwisectrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 232; Match(PERIPTOSI);
			State = 233; Match(ALLIOS);
			State = 234; statementlist();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionargumentsContext : ParserRuleContext {
		public FunctionargumentsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionarguments; } }
	 
		public FunctionargumentsContext() { }
		public virtual void CopyFrom(FunctionargumentsContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class FunargsContext : FunctionargumentsContext {
		public IReadOnlyList<ITerminalNode> COMMA() { return GetTokens(GLOSSAParser.COMMA); }
		public IReadOnlyList<ExpressionprimitivesContext> expressionprimitives() {
			return GetRuleContexts<ExpressionprimitivesContext>();
		}
		public ExpressionprimitivesContext expressionprimitives(int i) {
			return GetRuleContext<ExpressionprimitivesContext>(i);
		}
		public ITerminalNode COMMA(int i) {
			return GetToken(GLOSSAParser.COMMA, i);
		}
		public FunargsContext(FunctionargumentsContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterFunargs(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitFunargs(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunargs(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionargumentsContext functionarguments() {
		FunctionargumentsContext _localctx = new FunctionargumentsContext(_ctx, State);
		EnterRule(_localctx, 36, RULE_functionarguments);
		int _la;
		try {
			_localctx = new FunargsContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 236; expressionprimitives();
			State = 241;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 237; Match(COMMA);
				State = 238; expressionprimitives();
				}
				}
				State = 243;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AssignmentContext : ParserRuleContext {
		public AssignmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assignment; } }
	 
		public AssignmentContext() { }
		public virtual void CopyFrom(AssignmentContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class AssignContext : AssignmentContext {
		public ITerminalNode ASSIGNMENT() { return GetToken(GLOSSAParser.ASSIGNMENT, 0); }
		public ITerminalNode IDENTIFIER() { return GetToken(GLOSSAParser.IDENTIFIER, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public AssignContext(AssignmentContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterAssign(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitAssign(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssign(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AssignmentContext assignment() {
		AssignmentContext _localctx = new AssignmentContext(_ctx, State);
		EnterRule(_localctx, 38, RULE_assignment);
		try {
			_localctx = new AssignContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 244; Match(IDENTIFIER);
			State = 245; Match(ASSIGNMENT);
			State = 246; expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionprimitivesContext : ParserRuleContext {
		public ExpressionprimitivesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionprimitives; } }
	 
		public ExpressionprimitivesContext() { }
		public virtual void CopyFrom(ExpressionprimitivesContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Expressionprimitives_stringContext : ExpressionprimitivesContext {
		public ITerminalNode STRING() { return GetToken(GLOSSAParser.STRING, 0); }
		public Expressionprimitives_stringContext(ExpressionprimitivesContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpressionprimitives_string(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpressionprimitives_string(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionprimitives_string(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expressionprimitives_intContext : ExpressionprimitivesContext {
		public ITerminalNode INTEGER() { return GetToken(GLOSSAParser.INTEGER, 0); }
		public Expressionprimitives_intContext(ExpressionprimitivesContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpressionprimitives_int(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpressionprimitives_int(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionprimitives_int(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expressionprimitives_decContext : ExpressionprimitivesContext {
		public ITerminalNode DECIMAL() { return GetToken(GLOSSAParser.DECIMAL, 0); }
		public Expressionprimitives_decContext(ExpressionprimitivesContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpressionprimitives_dec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpressionprimitives_dec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionprimitives_dec(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expressionprimitives_identifierContext : ExpressionprimitivesContext {
		public ITerminalNode IDENTIFIER() { return GetToken(GLOSSAParser.IDENTIFIER, 0); }
		public Expressionprimitives_identifierContext(ExpressionprimitivesContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpressionprimitives_identifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpressionprimitives_identifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionprimitives_identifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionprimitivesContext expressionprimitives() {
		ExpressionprimitivesContext _localctx = new ExpressionprimitivesContext(_ctx, State);
		EnterRule(_localctx, 40, RULE_expressionprimitives);
		try {
			State = 252;
			switch (_input.La(1)) {
			case INTEGER:
				_localctx = new Expressionprimitives_intContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 248; Match(INTEGER);
				}
				break;
			case DECIMAL:
				_localctx = new Expressionprimitives_decContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 249; Match(DECIMAL);
				}
				break;
			case STRING:
				_localctx = new Expressionprimitives_stringContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 250; Match(STRING);
				}
				break;
			case IDENTIFIER:
				_localctx = new Expressionprimitives_identifierContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 251; Match(IDENTIFIER);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
	 
		public ExpressionContext() { }
		public virtual void CopyFrom(ExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Expr_compareContext : ExpressionContext {
		public IToken op;
		public ITerminalNode EQUALS() { return GetToken(GLOSSAParser.EQUALS, 0); }
		public ITerminalNode GE() { return GetToken(GLOSSAParser.GE, 0); }
		public ITerminalNode NOTEQUALS() { return GetToken(GLOSSAParser.NOTEQUALS, 0); }
		public ITerminalNode LT() { return GetToken(GLOSSAParser.LT, 0); }
		public ITerminalNode GT() { return GetToken(GLOSSAParser.GT, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode LE() { return GetToken(GLOSSAParser.LE, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public Expr_compareContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_compare(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_compare(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_compare(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_muldivContext : ExpressionContext {
		public IToken op;
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode DIV() { return GetToken(GLOSSAParser.DIV, 0); }
		public ITerminalNode MUL() { return GetToken(GLOSSAParser.MUL, 0); }
		public Expr_muldivContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_muldiv(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_muldiv(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_muldiv(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_orContext : ExpressionContext {
		public ITerminalNode H() { return GetToken(GLOSSAParser.H, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public Expr_orContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_or(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_or(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_or(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_powerContext : ExpressionContext {
		public ITerminalNode POWER() { return GetToken(GLOSSAParser.POWER, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public Expr_powerContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_power(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_power(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_power(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_andContext : ExpressionContext {
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode KAI() { return GetToken(GLOSSAParser.KAI, 0); }
		public Expr_andContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_and(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_and(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_and(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_parenContext : ExpressionContext {
		public ITerminalNode LPAREN() { return GetToken(GLOSSAParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(GLOSSAParser.RPAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Expr_parenContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_paren(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_paren(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_paren(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_funcproccallContext : ExpressionContext {
		public FunctionargumentsContext functionarguments() {
			return GetRuleContext<FunctionargumentsContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(GLOSSAParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(GLOSSAParser.RPAREN, 0); }
		public ITerminalNode IDENTIFIER() { return GetToken(GLOSSAParser.IDENTIFIER, 0); }
		public Expr_funcproccallContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_funcproccall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_funcproccall(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_funcproccall(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_expressionprimitivesContext : ExpressionContext {
		public ExpressionprimitivesContext expressionprimitives() {
			return GetRuleContext<ExpressionprimitivesContext>(0);
		}
		public Expr_expressionprimitivesContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_expressionprimitives(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_expressionprimitives(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_expressionprimitives(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_unaryContext : ExpressionContext {
		public IToken op;
		public ITerminalNode PLUS() { return GetToken(GLOSSAParser.PLUS, 0); }
		public ITerminalNode MINUS() { return GetToken(GLOSSAParser.MINUS, 0); }
		public ITerminalNode OXI() { return GetToken(GLOSSAParser.OXI, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Expr_unaryContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_unary(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_unary(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_unary(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_plusminusContext : ExpressionContext {
		public IToken op;
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode PLUS() { return GetToken(GLOSSAParser.PLUS, 0); }
		public ITerminalNode MINUS() { return GetToken(GLOSSAParser.MINUS, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public Expr_plusminusContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_plusminus(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_plusminus(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_plusminus(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		return expression(0);
	}

	private ExpressionContext expression(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		ExpressionContext _localctx = new ExpressionContext(_ctx, _parentState);
		ExpressionContext _prevctx = _localctx;
		int _startState = 42;
		EnterRecursionRule(_localctx, 42, RULE_expression, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 268;
			switch ( Interpreter.AdaptivePredict(_input,23,_ctx) ) {
			case 1:
				{
				_localctx = new Expr_unaryContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;

				State = 255;
				((Expr_unaryContext)_localctx).op = _input.Lt(1);
				_la = _input.La(1);
				if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << OXI) | (1L << PLUS) | (1L << MINUS))) != 0)) ) {
					((Expr_unaryContext)_localctx).op = _errHandler.RecoverInline(this);
				}
				Consume();
				State = 256; expression(8);
				}
				break;

			case 2:
				{
				_localctx = new Expr_parenContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 257; Match(LPAREN);
				State = 258; expression(0);
				State = 259; Match(RPAREN);
				}
				break;

			case 3:
				{
				_localctx = new Expr_funcproccallContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 261; Match(IDENTIFIER);
				State = 262; Match(LPAREN);
				State = 264;
				_la = _input.La(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << INTEGER) | (1L << DECIMAL) | (1L << STRING) | (1L << IDENTIFIER))) != 0)) {
					{
					State = 263; functionarguments();
					}
				}

				State = 266; Match(RPAREN);
				}
				break;

			case 4:
				{
				_localctx = new Expr_expressionprimitivesContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 267; expressionprimitives();
				}
				break;
			}
			_ctx.stop = _input.Lt(-1);
			State = 290;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,25,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 288;
					switch ( Interpreter.AdaptivePredict(_input,24,_ctx) ) {
					case 1:
						{
						_localctx = new Expr_powerContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 270;
						if (!(Precpred(_ctx, 9))) throw new FailedPredicateException(this, "Precpred(_ctx, 9)");
						State = 271; Match(POWER);
						State = 272; expression(9);
						}
						break;

					case 2:
						{
						_localctx = new Expr_muldivContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 273;
						if (!(Precpred(_ctx, 7))) throw new FailedPredicateException(this, "Precpred(_ctx, 7)");
						State = 274;
						((Expr_muldivContext)_localctx).op = _input.Lt(1);
						_la = _input.La(1);
						if ( !(_la==MUL || _la==DIV) ) {
							((Expr_muldivContext)_localctx).op = _errHandler.RecoverInline(this);
						}
						Consume();
						State = 275; expression(8);
						}
						break;

					case 3:
						{
						_localctx = new Expr_plusminusContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 276;
						if (!(Precpred(_ctx, 6))) throw new FailedPredicateException(this, "Precpred(_ctx, 6)");
						State = 277;
						((Expr_plusminusContext)_localctx).op = _input.Lt(1);
						_la = _input.La(1);
						if ( !(_la==PLUS || _la==MINUS) ) {
							((Expr_plusminusContext)_localctx).op = _errHandler.RecoverInline(this);
						}
						Consume();
						State = 278; expression(7);
						}
						break;

					case 4:
						{
						_localctx = new Expr_compareContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 279;
						if (!(Precpred(_ctx, 5))) throw new FailedPredicateException(this, "Precpred(_ctx, 5)");
						State = 280;
						((Expr_compareContext)_localctx).op = _input.Lt(1);
						_la = _input.La(1);
						if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << EQUALS) | (1L << NOTEQUALS) | (1L << GT) | (1L << GE) | (1L << LT) | (1L << LE))) != 0)) ) {
							((Expr_compareContext)_localctx).op = _errHandler.RecoverInline(this);
						}
						Consume();
						State = 281; expression(6);
						}
						break;

					case 5:
						{
						_localctx = new Expr_andContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 282;
						if (!(Precpred(_ctx, 4))) throw new FailedPredicateException(this, "Precpred(_ctx, 4)");
						State = 283; Match(KAI);
						State = 284; expression(5);
						}
						break;

					case 6:
						{
						_localctx = new Expr_orContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 285;
						if (!(Precpred(_ctx, 3))) throw new FailedPredicateException(this, "Precpred(_ctx, 3)");
						State = 286; Match(H);
						State = 287; expression(4);
						}
						break;
					}
					} 
				}
				State = 292;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,25,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class TypeContext : ParserRuleContext {
		public TypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type; } }
	 
		public TypeContext() { }
		public virtual void CopyFrom(TypeContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class TContext : TypeContext {
		public ITerminalNode AKERAIA() { return GetToken(GLOSSAParser.AKERAIA, 0); }
		public TContext(TypeContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterT(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitT(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitT(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Type_pragmatikesContext : TypeContext {
		public ITerminalNode PRAGMATIKES() { return GetToken(GLOSSAParser.PRAGMATIKES, 0); }
		public Type_pragmatikesContext(TypeContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterType_pragmatikes(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitType_pragmatikes(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_pragmatikes(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Type_xaraktiresContext : TypeContext {
		public ITerminalNode XARAKTHRES() { return GetToken(GLOSSAParser.XARAKTHRES, 0); }
		public Type_xaraktiresContext(TypeContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterType_xaraktires(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitType_xaraktires(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_xaraktires(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Type_akeraiesContext : TypeContext {
		public ITerminalNode AKERAIES() { return GetToken(GLOSSAParser.AKERAIES, 0); }
		public Type_akeraiesContext(TypeContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterType_akeraies(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitType_akeraies(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_akeraies(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Type_logikesContext : TypeContext {
		public ITerminalNode LOGIKES() { return GetToken(GLOSSAParser.LOGIKES, 0); }
		public Type_logikesContext(TypeContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterType_logikes(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitType_logikes(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_logikes(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeContext type() {
		TypeContext _localctx = new TypeContext(_ctx, State);
		EnterRule(_localctx, 44, RULE_type);
		try {
			State = 298;
			switch (_input.La(1)) {
			case AKERAIES:
				_localctx = new Type_akeraiesContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 293; Match(AKERAIES);
				}
				break;
			case PRAGMATIKES:
				_localctx = new Type_pragmatikesContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 294; Match(PRAGMATIKES);
				}
				break;
			case XARAKTHRES:
				_localctx = new Type_xaraktiresContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 295; Match(XARAKTHRES);
				}
				break;
			case LOGIKES:
				_localctx = new Type_logikesContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 296; Match(LOGIKES);
				}
				break;
			case AKERAIA:
				_localctx = new TContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 297; Match(AKERAIA);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class KeywordContext : ParserRuleContext {
		public KeywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_keyword; } }
	 
		public KeywordContext() { }
		public virtual void CopyFrom(KeywordContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Keyword_kaleseContext : KeywordContext {
		public ITerminalNode KALESE() { return GetToken(GLOSSAParser.KALESE, 0); }
		public Keyword_kaleseContext(KeywordContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterKeyword_kalese(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitKeyword_kalese(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitKeyword_kalese(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Keyword_diabaseContext : KeywordContext {
		public ITerminalNode DIABASE() { return GetToken(GLOSSAParser.DIABASE, 0); }
		public Keyword_diabaseContext(KeywordContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterKeyword_diabase(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitKeyword_diabase(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitKeyword_diabase(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Keyword_ektiposeContext : KeywordContext {
		public ITerminalNode EKTIPOSE() { return GetToken(GLOSSAParser.EKTIPOSE, 0); }
		public Keyword_ektiposeContext(KeywordContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterKeyword_ektipose(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitKeyword_ektipose(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitKeyword_ektipose(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Keyword_grapseContext : KeywordContext {
		public ITerminalNode GRAPSE() { return GetToken(GLOSSAParser.GRAPSE, 0); }
		public Keyword_grapseContext(KeywordContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterKeyword_grapse(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitKeyword_grapse(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitKeyword_grapse(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public KeywordContext keyword() {
		KeywordContext _localctx = new KeywordContext(_ctx, State);
		EnterRule(_localctx, 46, RULE_keyword);
		try {
			State = 304;
			switch (_input.La(1)) {
			case GRAPSE:
				_localctx = new Keyword_grapseContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 300; Match(GRAPSE);
				}
				break;
			case EKTIPOSE:
				_localctx = new Keyword_ektiposeContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 301; Match(EKTIPOSE);
				}
				break;
			case DIABASE:
				_localctx = new Keyword_diabaseContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 302; Match(DIABASE);
				}
				break;
			case KALESE:
				_localctx = new Keyword_kaleseContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 303; Match(KALESE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BoolContext : ParserRuleContext {
		public BoolContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bool; } }
	 
		public BoolContext() { }
		public virtual void CopyFrom(BoolContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Bool_trueContext : BoolContext {
		public ITerminalNode TRUE() { return GetToken(GLOSSAParser.TRUE, 0); }
		public Bool_trueContext(BoolContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterBool_true(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitBool_true(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBool_true(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Bool_falseContext : BoolContext {
		public ITerminalNode FALSE() { return GetToken(GLOSSAParser.FALSE, 0); }
		public Bool_falseContext(BoolContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterBool_false(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitBool_false(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBool_false(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BoolContext @bool() {
		BoolContext _localctx = new BoolContext(_ctx, State);
		EnterRule(_localctx, 48, RULE_bool);
		try {
			State = 308;
			switch (_input.La(1)) {
			case TRUE:
				_localctx = new Bool_trueContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 306; Match(TRUE);
				}
				break;
			case FALSE:
				_localctx = new Bool_falseContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 307; Match(FALSE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 21: return expression_sempred((ExpressionContext)_localctx, predIndex);
		}
		return true;
	}
	private bool expression_sempred(ExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(_ctx, 9);

		case 1: return Precpred(_ctx, 7);

		case 2: return Precpred(_ctx, 6);

		case 3: return Precpred(_ctx, 5);

		case 4: return Precpred(_ctx, 4);

		case 5: return Precpred(_ctx, 3);
		}
		return true;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3\x45\x139\x4\x2"+
		"\t\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4"+
		"\t\t\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10"+
		"\t\x10\x4\x11\t\x11\x4\x12\t\x12\x4\x13\t\x13\x4\x14\t\x14\x4\x15\t\x15"+
		"\x4\x16\t\x16\x4\x17\t\x17\x4\x18\t\x18\x4\x19\t\x19\x4\x1A\t\x1A\x3\x2"+
		"\x3\x2\x3\x2\a\x2\x38\n\x2\f\x2\xE\x2;\v\x2\x3\x3\x3\x3\x3\x3\a\x3@\n"+
		"\x3\f\x3\xE\x3\x43\v\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x4\x3\x4\x3\x4\x3\x4"+
		"\x5\x4M\n\x4\x3\x4\x3\x4\x3\x4\x3\x4\a\x4S\n\x4\f\x4\xE\x4V\v\x4\x3\x4"+
		"\x3\x4\x3\x4\x3\x4\x3\x5\x3\x5\x3\x5\x3\x5\x5\x5`\n\x5\x3\x5\x3\x5\a\x5"+
		"\x64\n\x5\f\x5\xE\x5g\v\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x6\a\x6n\n\x6\f"+
		"\x6\xE\x6q\v\x6\x3\a\x3\a\x3\a\x3\a\x3\a\x3\a\a\ay\n\a\f\a\xE\a|\v\a\x3"+
		"\a\x3\a\x3\a\x3\a\x5\a\x82\n\a\x3\b\x3\b\x5\b\x86\n\b\x3\t\x3\t\x3\t\x3"+
		"\t\x3\t\x3\t\a\t\x8E\n\t\f\t\xE\t\x91\v\t\x3\t\x3\t\x3\t\x3\t\x3\t\x6"+
		"\t\x98\n\t\r\t\xE\t\x99\x5\t\x9C\n\t\x3\n\x3\n\x3\n\x3\n\x6\n\xA2\n\n"+
		"\r\n\xE\n\xA3\x3\v\x3\v\x3\v\x3\v\a\v\xAA\n\v\f\v\xE\v\xAD\v\v\x3\v\a"+
		"\v\xB0\n\v\f\v\xE\v\xB3\v\v\x3\v\x5\v\xB6\n\v\x3\v\x3\v\x3\f\x3\f\x3\f"+
		"\x3\f\x3\f\x3\r\x3\r\x3\r\x3\xE\x3\xE\x3\xE\x3\xE\x3\xE\x3\xF\x3\xF\x3"+
		"\xF\x3\xF\x3\xF\x3\xF\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10"+
		"\x3\x10\x3\x10\x3\x10\x3\x10\x3\x11\x3\x11\x3\x11\x6\x11\xDB\n\x11\r\x11"+
		"\xE\x11\xDC\x3\x11\a\x11\xE0\n\x11\f\x11\xE\x11\xE3\v\x11\x3\x11\x3\x11"+
		"\x3\x12\x3\x12\x3\x12\x3\x12\x3\x13\x3\x13\x3\x13\x3\x13\x3\x14\x3\x14"+
		"\x3\x14\a\x14\xF2\n\x14\f\x14\xE\x14\xF5\v\x14\x3\x15\x3\x15\x3\x15\x3"+
		"\x15\x3\x16\x3\x16\x3\x16\x3\x16\x5\x16\xFF\n\x16\x3\x17\x3\x17\x3\x17"+
		"\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x5\x17\x10B\n\x17\x3"+
		"\x17\x3\x17\x5\x17\x10F\n\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17"+
		"\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17"+
		"\x3\x17\x3\x17\a\x17\x123\n\x17\f\x17\xE\x17\x126\v\x17\x3\x18\x3\x18"+
		"\x3\x18\x3\x18\x3\x18\x5\x18\x12D\n\x18\x3\x19\x3\x19\x3\x19\x3\x19\x5"+
		"\x19\x133\n\x19\x3\x1A\x3\x1A\x5\x1A\x137\n\x1A\x3\x1A\x2\x2\x3,\x1B\x2"+
		"\x2\x4\x2\x6\x2\b\x2\n\x2\f\x2\xE\x2\x10\x2\x12\x2\x14\x2\x16\x2\x18\x2"+
		"\x1A\x2\x1C\x2\x1E\x2 \x2\"\x2$\x2&\x2(\x2*\x2,\x2.\x2\x30\x2\x32\x2\x2"+
		"\x6\x4\x2++\x36\x37\x3\x2\x38\x39\x3\x2\x36\x37\x3\x2\x30\x35\x14E\x2"+
		"\x34\x3\x2\x2\x2\x4<\x3\x2\x2\x2\x6H\x3\x2\x2\x2\b[\x3\x2\x2\x2\no\x3"+
		"\x2\x2\x2\f\x81\x3\x2\x2\x2\xE\x85\x3\x2\x2\x2\x10\x9B\x3\x2\x2\x2\x12"+
		"\x9D\x3\x2\x2\x2\x14\xA5\x3\x2\x2\x2\x16\xB9\x3\x2\x2\x2\x18\xBE\x3\x2"+
		"\x2\x2\x1A\xC1\x3\x2\x2\x2\x1C\xC6\x3\x2\x2\x2\x1E\xCC\x3\x2\x2\x2 \xD7"+
		"\x3\x2\x2\x2\"\xE6\x3\x2\x2\x2$\xEA\x3\x2\x2\x2&\xEE\x3\x2\x2\x2(\xF6"+
		"\x3\x2\x2\x2*\xFE\x3\x2\x2\x2,\x10E\x3\x2\x2\x2.\x12C\x3\x2\x2\x2\x30"+
		"\x132\x3\x2\x2\x2\x32\x136\x3\x2\x2\x2\x34\x39\x5\x4\x3\x2\x35\x38\x5"+
		"\x6\x4\x2\x36\x38\x5\b\x5\x2\x37\x35\x3\x2\x2\x2\x37\x36\x3\x2\x2\x2\x38"+
		";\x3\x2\x2\x2\x39\x37\x3\x2\x2\x2\x39:\x3\x2\x2\x2:\x3\x3\x2\x2\x2;\x39"+
		"\x3\x2\x2\x2<=\a\x4\x2\x2=\x41\a/\x2\x2>@\x5\xE\b\x2?>\x3\x2\x2\x2@\x43"+
		"\x3\x2\x2\x2\x41?\x3\x2\x2\x2\x41\x42\x3\x2\x2\x2\x42\x44\x3\x2\x2\x2"+
		"\x43\x41\x3\x2\x2\x2\x44\x45\a\x5\x2\x2\x45\x46\x5\n\x6\x2\x46G\a\x6\x2"+
		"\x2G\x5\x3\x2\x2\x2HI\a\a\x2\x2IJ\a/\x2\x2JL\a>\x2\x2KM\x5&\x14\x2LK\x3"+
		"\x2\x2\x2LM\x3\x2\x2\x2MN\x3\x2\x2\x2NO\a?\x2\x2OP\a\x3\x2\x2PT\x5.\x18"+
		"\x2QS\x5\xE\b\x2RQ\x3\x2\x2\x2SV\x3\x2\x2\x2TR\x3\x2\x2\x2TU\x3\x2\x2"+
		"\x2UW\x3\x2\x2\x2VT\x3\x2\x2\x2WX\a\x5\x2\x2XY\x5\n\x6\x2YZ\a\b\x2\x2"+
		"Z\a\x3\x2\x2\x2[\\\a\t\x2\x2\\]\a/\x2\x2]_\a>\x2\x2^`\x5&\x14\x2_^\x3"+
		"\x2\x2\x2_`\x3\x2\x2\x2`\x61\x3\x2\x2\x2\x61\x65\a?\x2\x2\x62\x64\x5\xE"+
		"\b\x2\x63\x62\x3\x2\x2\x2\x64g\x3\x2\x2\x2\x65\x63\x3\x2\x2\x2\x65\x66"+
		"\x3\x2\x2\x2\x66h\x3\x2\x2\x2g\x65\x3\x2\x2\x2hi\a\x5\x2\x2ij\x5\n\x6"+
		"\x2jk\a\n\x2\x2k\t\x3\x2\x2\x2ln\x5\f\a\x2ml\x3\x2\x2\x2nq\x3\x2\x2\x2"+
		"om\x3\x2\x2\x2op\x3\x2\x2\x2p\v\x3\x2\x2\x2qo\x3\x2\x2\x2r\x82\x5,\x17"+
		"\x2s\x82\x5(\x15\x2tu\x5\x30\x19\x2uz\x5,\x17\x2vw\a<\x2\x2wy\x5,\x17"+
		"\x2xv\x3\x2\x2\x2y|\x3\x2\x2\x2zx\x3\x2\x2\x2z{\x3\x2\x2\x2{\x82\x3\x2"+
		"\x2\x2|z\x3\x2\x2\x2}\x82\x5\x14\v\x2~\x82\x5\x1A\xE\x2\x7F\x82\x5\x1C"+
		"\xF\x2\x80\x82\x5 \x11\x2\x81r\x3\x2\x2\x2\x81s\x3\x2\x2\x2\x81t\x3\x2"+
		"\x2\x2\x81}\x3\x2\x2\x2\x81~\x3\x2\x2\x2\x81\x7F\x3\x2\x2\x2\x81\x80\x3"+
		"\x2\x2\x2\x82\r\x3\x2\x2\x2\x83\x86\x5\x10\t\x2\x84\x86\x5\x12\n\x2\x85"+
		"\x83\x3\x2\x2\x2\x85\x84\x3\x2\x2\x2\x86\xF\x3\x2\x2\x2\x87\x88\a\v\x2"+
		"\x2\x88\x89\x5.\x18\x2\x89\x8A\a\x3\x2\x2\x8A\x8F\a/\x2\x2\x8B\x8C\a<"+
		"\x2\x2\x8C\x8E\a/\x2\x2\x8D\x8B\x3\x2\x2\x2\x8E\x91\x3\x2\x2\x2\x8F\x8D"+
		"\x3\x2\x2\x2\x8F\x90\x3\x2\x2\x2\x90\x9C\x3\x2\x2\x2\x91\x8F\x3\x2\x2"+
		"\x2\x92\x97\a\v\x2\x2\x93\x94\x5.\x18\x2\x94\x95\a\x3\x2\x2\x95\x96\a"+
		"/\x2\x2\x96\x98\x3\x2\x2\x2\x97\x93\x3\x2\x2\x2\x98\x99\x3\x2\x2\x2\x99"+
		"\x97\x3\x2\x2\x2\x99\x9A\x3\x2\x2\x2\x9A\x9C\x3\x2\x2\x2\x9B\x87\x3\x2"+
		"\x2\x2\x9B\x92\x3\x2\x2\x2\x9C\x11\x3\x2\x2\x2\x9D\xA1\a\f\x2\x2\x9E\x9F"+
		"\a/\x2\x2\x9F\xA0\a\x30\x2\x2\xA0\xA2\x5*\x16\x2\xA1\x9E\x3\x2\x2\x2\xA2"+
		"\xA3\x3\x2\x2\x2\xA3\xA1\x3\x2\x2\x2\xA3\xA4\x3\x2\x2\x2\xA4\x13\x3\x2"+
		"\x2\x2\xA5\xA6\a\r\x2\x2\xA6\xA7\x5,\x17\x2\xA7\xAB\a\xE\x2\x2\xA8\xAA"+
		"\x5\f\a\x2\xA9\xA8\x3\x2\x2\x2\xAA\xAD\x3\x2\x2\x2\xAB\xA9\x3\x2\x2\x2"+
		"\xAB\xAC\x3\x2\x2\x2\xAC\xB1\x3\x2\x2\x2\xAD\xAB\x3\x2\x2\x2\xAE\xB0\x5"+
		"\x16\f\x2\xAF\xAE\x3\x2\x2\x2\xB0\xB3\x3\x2\x2\x2\xB1\xAF\x3\x2\x2\x2"+
		"\xB1\xB2\x3\x2\x2\x2\xB2\xB5\x3\x2\x2\x2\xB3\xB1\x3\x2\x2\x2\xB4\xB6\x5"+
		"\x18\r\x2\xB5\xB4\x3\x2\x2\x2\xB5\xB6\x3\x2\x2\x2\xB6\xB7\x3\x2\x2\x2"+
		"\xB7\xB8\a\xF\x2\x2\xB8\x15\x3\x2\x2\x2\xB9\xBA\a\x10\x2\x2\xBA\xBB\x5"+
		",\x17\x2\xBB\xBC\a\xE\x2\x2\xBC\xBD\x5\n\x6\x2\xBD\x17\x3\x2\x2\x2\xBE"+
		"\xBF\a\x11\x2\x2\xBF\xC0\x5\n\x6\x2\xC0\x19\x3\x2\x2\x2\xC1\xC2\a\x12"+
		"\x2\x2\xC2\xC3\x5\n\x6\x2\xC3\xC4\a\x13\x2\x2\xC4\xC5\x5,\x17\x2\xC5\x1B"+
		"\x3\x2\x2\x2\xC6\xC7\a\x14\x2\x2\xC7\xC8\x5,\x17\x2\xC8\xC9\a\x15\x2\x2"+
		"\xC9\xCA\x5\n\x6\x2\xCA\xCB\a\x16\x2\x2\xCB\x1D\x3\x2\x2\x2\xCC\xCD\a"+
		"\x17\x2\x2\xCD\xCE\a/\x2\x2\xCE\xCF\a\x18\x2\x2\xCF\xD0\a,\x2\x2\xD0\xD1"+
		"\a\x19\x2\x2\xD1\xD2\a,\x2\x2\xD2\xD3\a\x1A\x2\x2\xD3\xD4\x5,\x17\x2\xD4"+
		"\xD5\x5\n\x6\x2\xD5\xD6\a\x16\x2\x2\xD6\x1F\x3\x2\x2\x2\xD7\xD8\a\x1B"+
		"\x2\x2\xD8\xDA\a/\x2\x2\xD9\xDB\x5\"\x12\x2\xDA\xD9\x3\x2\x2\x2\xDB\xDC"+
		"\x3\x2\x2\x2\xDC\xDA\x3\x2\x2\x2\xDC\xDD\x3\x2\x2\x2\xDD\xE1\x3\x2\x2"+
		"\x2\xDE\xE0\x5$\x13\x2\xDF\xDE\x3\x2\x2\x2\xE0\xE3\x3\x2\x2\x2\xE1\xDF"+
		"\x3\x2\x2\x2\xE1\xE2\x3\x2\x2\x2\xE2\xE4\x3\x2\x2\x2\xE3\xE1\x3\x2\x2"+
		"\x2\xE4\xE5\a\x1D\x2\x2\xE5!\x3\x2\x2\x2\xE6\xE7\a\x1C\x2\x2\xE7\xE8\x5"+
		",\x17\x2\xE8\xE9\x5\n\x6\x2\xE9#\x3\x2\x2\x2\xEA\xEB\a\x1C\x2\x2\xEB\xEC"+
		"\a\x11\x2\x2\xEC\xED\x5\n\x6\x2\xED%\x3\x2\x2\x2\xEE\xF3\x5*\x16\x2\xEF"+
		"\xF0\a<\x2\x2\xF0\xF2\x5*\x16\x2\xF1\xEF\x3\x2\x2\x2\xF2\xF5\x3\x2\x2"+
		"\x2\xF3\xF1\x3\x2\x2\x2\xF3\xF4\x3\x2\x2\x2\xF4\'\x3\x2\x2\x2\xF5\xF3"+
		"\x3\x2\x2\x2\xF6\xF7\a/\x2\x2\xF7\xF8\a=\x2\x2\xF8\xF9\x5,\x17\x2\xF9"+
		")\x3\x2\x2\x2\xFA\xFF\a,\x2\x2\xFB\xFF\a-\x2\x2\xFC\xFF\a.\x2\x2\xFD\xFF"+
		"\a/\x2\x2\xFE\xFA\x3\x2\x2\x2\xFE\xFB\x3\x2\x2\x2\xFE\xFC\x3\x2\x2\x2"+
		"\xFE\xFD\x3\x2\x2\x2\xFF+\x3\x2\x2\x2\x100\x101\b\x17\x1\x2\x101\x102"+
		"\t\x2\x2\x2\x102\x10F\x5,\x17\n\x103\x104\a>\x2\x2\x104\x105\x5,\x17\x2"+
		"\x105\x106\a?\x2\x2\x106\x10F\x3\x2\x2\x2\x107\x108\a/\x2\x2\x108\x10A"+
		"\a>\x2\x2\x109\x10B\x5&\x14\x2\x10A\x109\x3\x2\x2\x2\x10A\x10B\x3\x2\x2"+
		"\x2\x10B\x10C\x3\x2\x2\x2\x10C\x10F\a?\x2\x2\x10D\x10F\x5*\x16\x2\x10E"+
		"\x100\x3\x2\x2\x2\x10E\x103\x3\x2\x2\x2\x10E\x107\x3\x2\x2\x2\x10E\x10D"+
		"\x3\x2\x2\x2\x10F\x124\x3\x2\x2\x2\x110\x111\f\v\x2\x2\x111\x112\a:\x2"+
		"\x2\x112\x123\x5,\x17\v\x113\x114\f\t\x2\x2\x114\x115\t\x3\x2\x2\x115"+
		"\x123\x5,\x17\n\x116\x117\f\b\x2\x2\x117\x118\t\x4\x2\x2\x118\x123\x5"+
		",\x17\t\x119\x11A\f\a\x2\x2\x11A\x11B\t\x5\x2\x2\x11B\x123\x5,\x17\b\x11C"+
		"\x11D\f\x6\x2\x2\x11D\x11E\a)\x2\x2\x11E\x123\x5,\x17\a\x11F\x120\f\x5"+
		"\x2\x2\x120\x121\a*\x2\x2\x121\x123\x5,\x17\x6\x122\x110\x3\x2\x2\x2\x122"+
		"\x113\x3\x2\x2\x2\x122\x116\x3\x2\x2\x2\x122\x119\x3\x2\x2\x2\x122\x11C"+
		"\x3\x2\x2\x2\x122\x11F\x3\x2\x2\x2\x123\x126\x3\x2\x2\x2\x124\x122\x3"+
		"\x2\x2\x2\x124\x125\x3\x2\x2\x2\x125-\x3\x2\x2\x2\x126\x124\x3\x2\x2\x2"+
		"\x127\x12D\a\x1F\x2\x2\x128\x12D\a \x2\x2\x129\x12D\a!\x2\x2\x12A\x12D"+
		"\a\"\x2\x2\x12B\x12D\a\x1E\x2\x2\x12C\x127\x3\x2\x2\x2\x12C\x128\x3\x2"+
		"\x2\x2\x12C\x129\x3\x2\x2\x2\x12C\x12A\x3\x2\x2\x2\x12C\x12B\x3\x2\x2"+
		"\x2\x12D/\x3\x2\x2\x2\x12E\x133\a#\x2\x2\x12F\x133\a$\x2\x2\x130\x133"+
		"\a%\x2\x2\x131\x133\a&\x2\x2\x132\x12E\x3\x2\x2\x2\x132\x12F\x3\x2\x2"+
		"\x2\x132\x130\x3\x2\x2\x2\x132\x131\x3\x2\x2\x2\x133\x31\x3\x2\x2\x2\x134"+
		"\x137\a\'\x2\x2\x135\x137\a(\x2\x2\x136\x134\x3\x2\x2\x2\x136\x135\x3"+
		"\x2\x2\x2\x137\x33\x3\x2\x2\x2\x1F\x37\x39\x41LT_\x65oz\x81\x85\x8F\x99"+
		"\x9B\xA3\xAB\xB1\xB5\xDC\xE1\xF3\xFE\x10A\x10E\x122\x124\x12C\x132\x136";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace Glossa
