//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.4.1-SNAPSHOT
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:\Users\Sonic\Documents\Visual Studio 2013\Projects\Glossa\Glossa\GLOSSA.g4 by ANTLR 4.4.1-SNAPSHOT

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591

namespace Glossa {
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.4.1-SNAPSHOT")]
[System.CLSCompliant(false)]
public partial class GLOSSAParser : Parser {
	public const int
		T__0=1, PROGRAMMA=2, ARXH=3, TELOS_PROGRAMMATOS=4, SYNARTHSH=5, TELOS_SYNARTHSHS=6, 
		DIADIKASIA=7, TELOS_DIADIKASIAS=8, METABLHTES=9, STATHERES=10, AN=11, 
		TOTE=12, TELOS_AN=13, ALLIOS_AN=14, ALLIOS=15, ARXH_EPANALIPSIS=16, MEXRIS_OTOU=17, 
		OSO=18, EPANALABE=19, TELOS_EPANALIPSIS=20, GIA=21, APO=22, MEXRI=23, 
		ME_BHMA=24, EPILEKSE=25, PERIPTOSI=26, TELOS_EPILOGON=27, AKERAIES=28, 
		PRAGMATIKES=29, XARAKTHRES=30, LOGIKES=31, GRAPSE=32, EKTIPOSE=33, DIABASE=34, 
		KALESE=35, TRUE=36, FALSE=37, KAI=38, H=39, OXI=40, INTEGER=41, DECIMAL=42, 
		STRING=43, IDENTIFIER=44, EQUALS=45, NOTEQUALS=46, GT=47, GE=48, LT=49, 
		LE=50, PLUS=51, MINUS=52, MUL=53, DIV=54, POWER=55, SEMICOLON=56, COMMA=57, 
		ASSIGNMENT=58, LPAREN=59, RPAREN=60, LBRACKET=61, RBRACKET=62, LANCHOR=63, 
		RANCHOR=64, COMMENTS=65, WS=66;
	public const int
		RULE_file = 0, RULE_program = 1, RULE_statementlist = 2, RULE_statement = 3, 
		RULE_declarations = 4, RULE_functiondefinition = 5, RULE_proceduredefinition = 6, 
		RULE_variabledeclarations = 7, RULE_constantdeclarations = 8, RULE_ifcontrol = 9, 
		RULE_elseif = 10, RULE_else = 11, RULE_dowhileloop = 12, RULE_whileloop = 13, 
		RULE_forloop = 14, RULE_switchcontrol = 15, RULE_casescontrol = 16, RULE_otherwisecontrol = 17, 
		RULE_functionarguments = 18, RULE_assignment = 19, RULE_expression = 20, 
		RULE_expressionprimitives = 21, RULE_type = 22, RULE_keyword = 23, RULE_bool = 24;
	public static readonly string[] ruleNames = {
		"file", "program", "statementlist", "statement", "declarations", "functiondefinition", 
		"proceduredefinition", "variabledeclarations", "constantdeclarations", 
		"ifcontrol", "elseif", "else", "dowhileloop", "whileloop", "forloop", 
		"switchcontrol", "casescontrol", "otherwisecontrol", "functionarguments", 
		"assignment", "expression", "expressionprimitives", "type", "keyword", 
		"bool"
	};

	private static readonly string[] _LiteralNames = {
		null, "':'", "'пяоцяалла'", "'аявг'", "'текос_пяоцяаллатос'", "'сумаятгсг'", 
		"'текос_сумаятгсгс'", "'диадийасиа'", "'текос_диадийасиас'", "'летабкгтес'", 
		"'стахеяес'", "'ам'", "'тоте'", "'текос_ам'", "'аккиыс_ам'", "'аккиыс'", 
		"'аявг_епамакгьгс'", "'левяис_отоу'", "'осо'", "'епамакабе'", "'текос_епамакгьгс'", 
		"'циа'", "'апо'", "'левяи'", "'ле_бгла'", "'епикене'", "'пеяиптысг'", 
		"'текос_епикоцым'", "'айеяаиес'", "'пяацлатийес'", "'ваяайтгяес'", "'коцийес'", 
		"'цяаье'", "'ейтупысе'", "'диабасе'", "'йакесе'", "'акгхгс'", "'ьеудгс'", 
		"'йаи'", "'г'", "'ови'", null, null, null, null, "'='", "'<>'", "'>'", 
		"'>='", "'<'", "'<='", "'+'", "'-'", "'*'", "'/'", "'^'", "';'", "','", 
		"'<-'", "'('", "')'", "'['", "']'", "'{'", "'}'"
	};
	private static readonly string[] _SymbolicNames = {
		null, null, "PROGRAMMA", "ARXH", "TELOS_PROGRAMMATOS", "SYNARTHSH", "TELOS_SYNARTHSHS", 
		"DIADIKASIA", "TELOS_DIADIKASIAS", "METABLHTES", "STATHERES", "AN", "TOTE", 
		"TELOS_AN", "ALLIOS_AN", "ALLIOS", "ARXH_EPANALIPSIS", "MEXRIS_OTOU", 
		"OSO", "EPANALABE", "TELOS_EPANALIPSIS", "GIA", "APO", "MEXRI", "ME_BHMA", 
		"EPILEKSE", "PERIPTOSI", "TELOS_EPILOGON", "AKERAIES", "PRAGMATIKES", 
		"XARAKTHRES", "LOGIKES", "GRAPSE", "EKTIPOSE", "DIABASE", "KALESE", "TRUE", 
		"FALSE", "KAI", "H", "OXI", "INTEGER", "DECIMAL", "STRING", "IDENTIFIER", 
		"EQUALS", "NOTEQUALS", "GT", "GE", "LT", "LE", "PLUS", "MINUS", "MUL", 
		"DIV", "POWER", "SEMICOLON", "COMMA", "ASSIGNMENT", "LPAREN", "RPAREN", 
		"LBRACKET", "RBRACKET", "LANCHOR", "RANCHOR", "COMMENTS", "WS"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[System.Obsolete("Use Vocabulary instead.")]
	public static readonly string[] tokenNames = GenerateTokenNames(DefaultVocabulary, _SymbolicNames.Length);

	private static string[] GenerateTokenNames(IVocabulary vocabulary, int length) {
		string[] tokenNames = new string[length];
		for (int i = 0; i < tokenNames.Length; i++) {
			tokenNames[i] = vocabulary.GetLiteralName(i);
			if (tokenNames[i] == null) {
				tokenNames[i] = vocabulary.GetSymbolicName(i);
			}

			if (tokenNames[i] == null) {
				tokenNames[i] = "<INVALID>";
			}
		}

		return tokenNames;
	}

	[System.Obsolete]
	public override string[] TokenNames
	{
		get
		{
			return tokenNames;
		}
	}

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "GLOSSA.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public GLOSSAParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class FileContext : ParserRuleContext {
		public FileContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_file; } }
	 
		public FileContext() { }
		public virtual void CopyFrom(FileContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class FilestartContext : FileContext {
		public IReadOnlyList<FunctiondefinitionContext> functiondefinition() {
			return GetRuleContexts<FunctiondefinitionContext>();
		}
		public ProgramContext program() {
			return GetRuleContext<ProgramContext>(0);
		}
		public FunctiondefinitionContext functiondefinition(int i) {
			return GetRuleContext<FunctiondefinitionContext>(i);
		}
		public IReadOnlyList<ProceduredefinitionContext> proceduredefinition() {
			return GetRuleContexts<ProceduredefinitionContext>();
		}
		public ProceduredefinitionContext proceduredefinition(int i) {
			return GetRuleContext<ProceduredefinitionContext>(i);
		}
		public FilestartContext(FileContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterFilestart(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitFilestart(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFilestart(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FileContext file() {
		FileContext _localctx = new FileContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_file);
		int _la;
		try {
			_localctx = new FilestartContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 50; program();
			State = 55;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==SYNARTHSH || _la==DIADIKASIA) {
				{
				State = 53;
				switch (_input.La(1)) {
				case SYNARTHSH:
					{
					State = 51; functiondefinition();
					}
					break;
				case DIADIKASIA:
					{
					State = 52; proceduredefinition();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 57;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProgramContext : ParserRuleContext {
		public ProgramContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_program; } }
	 
		public ProgramContext() { }
		public virtual void CopyFrom(ProgramContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ProgramstartContext : ProgramContext {
		public DeclarationsContext declarations(int i) {
			return GetRuleContext<DeclarationsContext>(i);
		}
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public ITerminalNode TELOS_PROGRAMMATOS() { return GetToken(GLOSSAParser.TELOS_PROGRAMMATOS, 0); }
		public IReadOnlyList<DeclarationsContext> declarations() {
			return GetRuleContexts<DeclarationsContext>();
		}
		public ITerminalNode ARXH() { return GetToken(GLOSSAParser.ARXH, 0); }
		public ITerminalNode PROGRAMMA() { return GetToken(GLOSSAParser.PROGRAMMA, 0); }
		public ITerminalNode IDENTIFIER() { return GetToken(GLOSSAParser.IDENTIFIER, 0); }
		public ProgramstartContext(ProgramContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterProgramstart(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitProgramstart(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProgramstart(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ProgramContext program() {
		ProgramContext _localctx = new ProgramContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_program);
		int _la;
		try {
			_localctx = new ProgramstartContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 58; Match(PROGRAMMA);
			State = 59; Match(IDENTIFIER);
			State = 63;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==METABLHTES || _la==STATHERES) {
				{
				{
				State = 60; declarations();
				}
				}
				State = 65;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 66; Match(ARXH);
			State = 67; statementlist();
			State = 68; Match(TELOS_PROGRAMMATOS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementlistContext : ParserRuleContext {
		public StatementlistContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statementlist; } }
	 
		public StatementlistContext() { }
		public virtual void CopyFrom(StatementlistContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class StmtlistContext : StatementlistContext {
		public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public IReadOnlyList<StatementContext> statement() {
			return GetRuleContexts<StatementContext>();
		}
		public StmtlistContext(StatementlistContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterStmtlist(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitStmtlist(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStmtlist(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementlistContext statementlist() {
		StatementlistContext _localctx = new StatementlistContext(_ctx, State);
		EnterRule(_localctx, 4, RULE_statementlist);
		int _la;
		try {
			_localctx = new StmtlistContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 73;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AN) | (1L << GRAPSE) | (1L << EKTIPOSE) | (1L << DIABASE) | (1L << KALESE) | (1L << OXI) | (1L << INTEGER) | (1L << DECIMAL) | (1L << STRING) | (1L << IDENTIFIER) | (1L << PLUS) | (1L << MINUS) | (1L << LPAREN))) != 0)) {
				{
				{
				State = 70; statement();
				}
				}
				State = 75;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
	 
		public StatementContext() { }
		public virtual void CopyFrom(StatementContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Stat_ifctrlContext : StatementContext {
		public IfcontrolContext ifcontrol() {
			return GetRuleContext<IfcontrolContext>(0);
		}
		public Stat_ifctrlContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterStat_ifctrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitStat_ifctrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStat_ifctrl(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Stat_ioexprContext : StatementContext {
		public ITerminalNode COMMA() { return GetToken(GLOSSAParser.COMMA, 0); }
		public KeywordContext keyword() {
			return GetRuleContext<KeywordContext>(0);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public Stat_ioexprContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterStat_ioexpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitStat_ioexpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStat_ioexpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Stat_assignmentContext : StatementContext {
		public AssignmentContext assignment() {
			return GetRuleContext<AssignmentContext>(0);
		}
		public Stat_assignmentContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterStat_assignment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitStat_assignment(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStat_assignment(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Stat_exprContext : StatementContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Stat_exprContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterStat_expr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitStat_expr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStat_expr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_statement);
		int _la;
		try {
			State = 85;
			switch ( Interpreter.AdaptivePredict(_input,5,_ctx) ) {
			case 1:
				_localctx = new Stat_exprContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 76; expression(0);
				}
				break;

			case 2:
				_localctx = new Stat_assignmentContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 77; assignment();
				}
				break;

			case 3:
				_localctx = new Stat_ioexprContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 78; keyword();
				State = 79; expression(0);
				State = 82;
				_la = _input.La(1);
				if (_la==COMMA) {
					{
					State = 80; Match(COMMA);
					State = 81; expression(0);
					}
				}

				}
				break;

			case 4:
				_localctx = new Stat_ifctrlContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 84; ifcontrol();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclarationsContext : ParserRuleContext {
		public DeclarationsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declarations; } }
	 
		public DeclarationsContext() { }
		public virtual void CopyFrom(DeclarationsContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ConstdeclContext : DeclarationsContext {
		public ConstantdeclarationsContext constantdeclarations() {
			return GetRuleContext<ConstantdeclarationsContext>(0);
		}
		public ConstdeclContext(DeclarationsContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterConstdecl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitConstdecl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstdecl(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class VardeclContext : DeclarationsContext {
		public VariabledeclarationsContext variabledeclarations() {
			return GetRuleContext<VariabledeclarationsContext>(0);
		}
		public VardeclContext(DeclarationsContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterVardecl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitVardecl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVardecl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclarationsContext declarations() {
		DeclarationsContext _localctx = new DeclarationsContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_declarations);
		try {
			State = 89;
			switch (_input.La(1)) {
			case METABLHTES:
				_localctx = new VardeclContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 87; variabledeclarations();
				}
				break;
			case STATHERES:
				_localctx = new ConstdeclContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 88; constantdeclarations();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctiondefinitionContext : ParserRuleContext {
		public FunctiondefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functiondefinition; } }
	 
		public FunctiondefinitionContext() { }
		public virtual void CopyFrom(FunctiondefinitionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Funcdef1Context : FunctiondefinitionContext {
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public ITerminalNode SYNARTHSH() { return GetToken(GLOSSAParser.SYNARTHSH, 0); }
		public ITerminalNode IDENTIFIER(int i) {
			return GetToken(GLOSSAParser.IDENTIFIER, i);
		}
		public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public IReadOnlyList<ITerminalNode> IDENTIFIER() { return GetTokens(GLOSSAParser.IDENTIFIER); }
		public ITerminalNode TELOS_SYNARTHSHS() { return GetToken(GLOSSAParser.TELOS_SYNARTHSHS, 0); }
		public Funcdef1Context(FunctiondefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterFuncdef1(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitFuncdef1(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFuncdef1(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Funcdef2Context : FunctiondefinitionContext {
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public ITerminalNode SYNARTHSH() { return GetToken(GLOSSAParser.SYNARTHSH, 0); }
		public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public ITerminalNode IDENTIFIER() { return GetToken(GLOSSAParser.IDENTIFIER, 0); }
		public ITerminalNode TELOS_SYNARTHSHS() { return GetToken(GLOSSAParser.TELOS_SYNARTHSHS, 0); }
		public Funcdef2Context(FunctiondefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterFuncdef2(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitFuncdef2(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFuncdef2(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctiondefinitionContext functiondefinition() {
		FunctiondefinitionContext _localctx = new FunctiondefinitionContext(_ctx, State);
		EnterRule(_localctx, 10, RULE_functiondefinition);
		int _la;
		try {
			State = 117;
			switch ( Interpreter.AdaptivePredict(_input,9,_ctx) ) {
			case 1:
				_localctx = new Funcdef1Context(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 91; Match(SYNARTHSH);
				State = 92; Match(IDENTIFIER);
				State = 103;
				_la = _input.La(1);
				if (_la==LPAREN) {
					{
					State = 93; Match(LPAREN);
					State = 94; Match(IDENTIFIER);
					State = 99;
					_errHandler.Sync(this);
					_la = _input.La(1);
					while (_la==COMMA) {
						{
						{
						State = 95; Match(COMMA);
						State = 96; Match(IDENTIFIER);
						}
						}
						State = 101;
						_errHandler.Sync(this);
						_la = _input.La(1);
					}
					State = 102; Match(RPAREN);
					}
				}

				State = 105; Match(T__0);
				State = 106; type();
				State = 107; statementlist();
				State = 108; Match(TELOS_SYNARTHSHS);
				}
				break;

			case 2:
				_localctx = new Funcdef2Context(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 110; Match(SYNARTHSH);
				State = 111; Match(IDENTIFIER);
				State = 112; Match(T__0);
				State = 113; type();
				State = 114; statementlist();
				State = 115; Match(TELOS_SYNARTHSHS);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProceduredefinitionContext : ParserRuleContext {
		public ProceduredefinitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_proceduredefinition; } }
	 
		public ProceduredefinitionContext() { }
		public virtual void CopyFrom(ProceduredefinitionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Procdef1Context : ProceduredefinitionContext {
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public ITerminalNode IDENTIFIER(int i) {
			return GetToken(GLOSSAParser.IDENTIFIER, i);
		}
		public ITerminalNode TELOS_DIADIKASIAS() { return GetToken(GLOSSAParser.TELOS_DIADIKASIAS, 0); }
		public ITerminalNode DIADIKASIA() { return GetToken(GLOSSAParser.DIADIKASIA, 0); }
		public IReadOnlyList<ITerminalNode> IDENTIFIER() { return GetTokens(GLOSSAParser.IDENTIFIER); }
		public Procdef1Context(ProceduredefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterProcdef1(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitProcdef1(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProcdef1(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Procdef2Context : ProceduredefinitionContext {
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public ITerminalNode TELOS_DIADIKASIAS() { return GetToken(GLOSSAParser.TELOS_DIADIKASIAS, 0); }
		public ITerminalNode DIADIKASIA() { return GetToken(GLOSSAParser.DIADIKASIA, 0); }
		public ITerminalNode IDENTIFIER() { return GetToken(GLOSSAParser.IDENTIFIER, 0); }
		public Procdef2Context(ProceduredefinitionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterProcdef2(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitProcdef2(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProcdef2(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ProceduredefinitionContext proceduredefinition() {
		ProceduredefinitionContext _localctx = new ProceduredefinitionContext(_ctx, State);
		EnterRule(_localctx, 12, RULE_proceduredefinition);
		int _la;
		try {
			State = 141;
			switch ( Interpreter.AdaptivePredict(_input,12,_ctx) ) {
			case 1:
				_localctx = new Procdef1Context(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 119; Match(DIADIKASIA);
				State = 120; Match(IDENTIFIER);
				State = 131;
				switch ( Interpreter.AdaptivePredict(_input,11,_ctx) ) {
				case 1:
					{
					State = 121; Match(LPAREN);
					State = 122; Match(IDENTIFIER);
					State = 127;
					_errHandler.Sync(this);
					_la = _input.La(1);
					while (_la==COMMA) {
						{
						{
						State = 123; Match(COMMA);
						State = 124; Match(IDENTIFIER);
						}
						}
						State = 129;
						_errHandler.Sync(this);
						_la = _input.La(1);
					}
					State = 130; Match(RPAREN);
					}
					break;
				}
				State = 133; statementlist();
				State = 134; Match(TELOS_DIADIKASIAS);
				}
				break;

			case 2:
				_localctx = new Procdef2Context(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 136; Match(DIADIKASIA);
				State = 137; Match(IDENTIFIER);
				State = 138; statementlist();
				State = 139; Match(TELOS_DIADIKASIAS);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VariabledeclarationsContext : ParserRuleContext {
		public VariabledeclarationsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variabledeclarations; } }
	 
		public VariabledeclarationsContext() { }
		public virtual void CopyFrom(VariabledeclarationsContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Vardecl_alt2Context : VariabledeclarationsContext {
		public TypeContext type(int i) {
			return GetRuleContext<TypeContext>(i);
		}
		public ITerminalNode IDENTIFIER(int i) {
			return GetToken(GLOSSAParser.IDENTIFIER, i);
		}
		public IReadOnlyList<TypeContext> type() {
			return GetRuleContexts<TypeContext>();
		}
		public ITerminalNode METABLHTES() { return GetToken(GLOSSAParser.METABLHTES, 0); }
		public IReadOnlyList<ITerminalNode> IDENTIFIER() { return GetTokens(GLOSSAParser.IDENTIFIER); }
		public Vardecl_alt2Context(VariabledeclarationsContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterVardecl_alt2(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitVardecl_alt2(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVardecl_alt2(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Vardecl_alt1Context : VariabledeclarationsContext {
		public ITerminalNode IDENTIFIER(int i) {
			return GetToken(GLOSSAParser.IDENTIFIER, i);
		}
		public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public ITerminalNode METABLHTES() { return GetToken(GLOSSAParser.METABLHTES, 0); }
		public IReadOnlyList<ITerminalNode> IDENTIFIER() { return GetTokens(GLOSSAParser.IDENTIFIER); }
		public Vardecl_alt1Context(VariabledeclarationsContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterVardecl_alt1(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitVardecl_alt1(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVardecl_alt1(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VariabledeclarationsContext variabledeclarations() {
		VariabledeclarationsContext _localctx = new VariabledeclarationsContext(_ctx, State);
		EnterRule(_localctx, 14, RULE_variabledeclarations);
		int _la;
		try {
			State = 163;
			switch ( Interpreter.AdaptivePredict(_input,15,_ctx) ) {
			case 1:
				_localctx = new Vardecl_alt1Context(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 143; Match(METABLHTES);
				State = 144; type();
				State = 145; Match(T__0);
				State = 146; Match(IDENTIFIER);
				State = 151;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 147; Match(COMMA);
					State = 148; Match(IDENTIFIER);
					}
					}
					State = 153;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
				break;

			case 2:
				_localctx = new Vardecl_alt2Context(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 154; Match(METABLHTES);
				State = 159;
				_errHandler.Sync(this);
				_la = _input.La(1);
				do {
					{
					{
					State = 155; type();
					State = 156; Match(T__0);
					State = 157; Match(IDENTIFIER);
					}
					}
					State = 161;
					_errHandler.Sync(this);
					_la = _input.La(1);
				} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AKERAIES) | (1L << PRAGMATIKES) | (1L << XARAKTHRES) | (1L << LOGIKES))) != 0) );
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstantdeclarationsContext : ParserRuleContext {
		public ConstantdeclarationsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constantdeclarations; } }
	 
		public ConstantdeclarationsContext() { }
		public virtual void CopyFrom(ConstantdeclarationsContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Constdecl_alt1Context : ConstantdeclarationsContext {
		public IReadOnlyList<ITerminalNode> EQUALS() { return GetTokens(GLOSSAParser.EQUALS); }
		public ITerminalNode STATHERES() { return GetToken(GLOSSAParser.STATHERES, 0); }
		public ITerminalNode IDENTIFIER(int i) {
			return GetToken(GLOSSAParser.IDENTIFIER, i);
		}
		public ITerminalNode EQUALS(int i) {
			return GetToken(GLOSSAParser.EQUALS, i);
		}
		public IReadOnlyList<ITerminalNode> IDENTIFIER() { return GetTokens(GLOSSAParser.IDENTIFIER); }
		public IReadOnlyList<ExpressionprimitivesContext> expressionprimitives() {
			return GetRuleContexts<ExpressionprimitivesContext>();
		}
		public ExpressionprimitivesContext expressionprimitives(int i) {
			return GetRuleContext<ExpressionprimitivesContext>(i);
		}
		public Constdecl_alt1Context(ConstantdeclarationsContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterConstdecl_alt1(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitConstdecl_alt1(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstdecl_alt1(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConstantdeclarationsContext constantdeclarations() {
		ConstantdeclarationsContext _localctx = new ConstantdeclarationsContext(_ctx, State);
		EnterRule(_localctx, 16, RULE_constantdeclarations);
		int _la;
		try {
			_localctx = new Constdecl_alt1Context(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 165; Match(STATHERES);
			State = 169;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 166; Match(IDENTIFIER);
				State = 167; Match(EQUALS);
				State = 168; expressionprimitives();
				}
				}
				State = 171;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==IDENTIFIER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfcontrolContext : ParserRuleContext {
		public IfcontrolContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifcontrol; } }
	 
		public IfcontrolContext() { }
		public virtual void CopyFrom(IfcontrolContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class IfctrlContext : IfcontrolContext {
		public IReadOnlyList<ElseifContext> elseif() {
			return GetRuleContexts<ElseifContext>();
		}
		public ITerminalNode TOTE() { return GetToken(GLOSSAParser.TOTE, 0); }
		public ITerminalNode TELOS_AN() { return GetToken(GLOSSAParser.TELOS_AN, 0); }
		public ITerminalNode AN() { return GetToken(GLOSSAParser.AN, 0); }
		public ElseContext @else() {
			return GetRuleContext<ElseContext>(0);
		}
		public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public ElseifContext elseif(int i) {
			return GetRuleContext<ElseifContext>(i);
		}
		public IReadOnlyList<StatementContext> statement() {
			return GetRuleContexts<StatementContext>();
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public IfctrlContext(IfcontrolContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterIfctrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitIfctrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfctrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IfcontrolContext ifcontrol() {
		IfcontrolContext _localctx = new IfcontrolContext(_ctx, State);
		EnterRule(_localctx, 18, RULE_ifcontrol);
		int _la;
		try {
			_localctx = new IfctrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 173; Match(AN);
			State = 174; expression(0);
			State = 175; Match(TOTE);
			State = 179;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AN) | (1L << GRAPSE) | (1L << EKTIPOSE) | (1L << DIABASE) | (1L << KALESE) | (1L << OXI) | (1L << INTEGER) | (1L << DECIMAL) | (1L << STRING) | (1L << IDENTIFIER) | (1L << PLUS) | (1L << MINUS) | (1L << LPAREN))) != 0)) {
				{
				{
				State = 176; statement();
				}
				}
				State = 181;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 185;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==ALLIOS_AN) {
				{
				{
				State = 182; elseif();
				}
				}
				State = 187;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 189;
			_la = _input.La(1);
			if (_la==ALLIOS) {
				{
				State = 188; @else();
				}
			}

			State = 191; Match(TELOS_AN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElseifContext : ParserRuleContext {
		public ElseifContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elseif; } }
	 
		public ElseifContext() { }
		public virtual void CopyFrom(ElseifContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ElseifctrlContext : ElseifContext {
		public ITerminalNode TOTE() { return GetToken(GLOSSAParser.TOTE, 0); }
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public ITerminalNode ALLIOS_AN() { return GetToken(GLOSSAParser.ALLIOS_AN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ElseifctrlContext(ElseifContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterElseifctrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitElseifctrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElseifctrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElseifContext elseif() {
		ElseifContext _localctx = new ElseifContext(_ctx, State);
		EnterRule(_localctx, 20, RULE_elseif);
		try {
			_localctx = new ElseifctrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 193; Match(ALLIOS_AN);
			State = 194; expression(0);
			State = 195; Match(TOTE);
			State = 196; statementlist();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElseContext : ParserRuleContext {
		public ElseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_else; } }
	 
		public ElseContext() { }
		public virtual void CopyFrom(ElseContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ElsectrlContext : ElseContext {
		public ITerminalNode ALLIOS() { return GetToken(GLOSSAParser.ALLIOS, 0); }
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public ElsectrlContext(ElseContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterElsectrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitElsectrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElsectrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElseContext @else() {
		ElseContext _localctx = new ElseContext(_ctx, State);
		EnterRule(_localctx, 22, RULE_else);
		try {
			_localctx = new ElsectrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 198; Match(ALLIOS);
			State = 199; statementlist();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DowhileloopContext : ParserRuleContext {
		public DowhileloopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dowhileloop; } }
	 
		public DowhileloopContext() { }
		public virtual void CopyFrom(DowhileloopContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class DowhilectrlContext : DowhileloopContext {
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public ITerminalNode MEXRIS_OTOU() { return GetToken(GLOSSAParser.MEXRIS_OTOU, 0); }
		public ITerminalNode ARXH_EPANALIPSIS() { return GetToken(GLOSSAParser.ARXH_EPANALIPSIS, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public DowhilectrlContext(DowhileloopContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterDowhilectrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitDowhilectrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDowhilectrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DowhileloopContext dowhileloop() {
		DowhileloopContext _localctx = new DowhileloopContext(_ctx, State);
		EnterRule(_localctx, 24, RULE_dowhileloop);
		try {
			_localctx = new DowhilectrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 201; Match(ARXH_EPANALIPSIS);
			State = 202; statementlist();
			State = 203; Match(MEXRIS_OTOU);
			State = 204; expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhileloopContext : ParserRuleContext {
		public WhileloopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whileloop; } }
	 
		public WhileloopContext() { }
		public virtual void CopyFrom(WhileloopContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class WhilectrlContext : WhileloopContext {
		public ITerminalNode EPANALABE() { return GetToken(GLOSSAParser.EPANALABE, 0); }
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public ITerminalNode OSO() { return GetToken(GLOSSAParser.OSO, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode TELOS_EPANALIPSIS() { return GetToken(GLOSSAParser.TELOS_EPANALIPSIS, 0); }
		public WhilectrlContext(WhileloopContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterWhilectrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitWhilectrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhilectrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WhileloopContext whileloop() {
		WhileloopContext _localctx = new WhileloopContext(_ctx, State);
		EnterRule(_localctx, 26, RULE_whileloop);
		try {
			_localctx = new WhilectrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 206; Match(OSO);
			State = 207; expression(0);
			State = 208; Match(EPANALABE);
			State = 209; statementlist();
			State = 210; Match(TELOS_EPANALIPSIS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForloopContext : ParserRuleContext {
		public ForloopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forloop; } }
	 
		public ForloopContext() { }
		public virtual void CopyFrom(ForloopContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ForctrlContext : ForloopContext {
		public ITerminalNode ME_BHMA() { return GetToken(GLOSSAParser.ME_BHMA, 0); }
		public IReadOnlyList<ITerminalNode> INTEGER() { return GetTokens(GLOSSAParser.INTEGER); }
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public ITerminalNode MEXRI() { return GetToken(GLOSSAParser.MEXRI, 0); }
		public ITerminalNode APO() { return GetToken(GLOSSAParser.APO, 0); }
		public ITerminalNode INTEGER(int i) {
			return GetToken(GLOSSAParser.INTEGER, i);
		}
		public ITerminalNode IDENTIFIER() { return GetToken(GLOSSAParser.IDENTIFIER, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode TELOS_EPANALIPSIS() { return GetToken(GLOSSAParser.TELOS_EPANALIPSIS, 0); }
		public ITerminalNode GIA() { return GetToken(GLOSSAParser.GIA, 0); }
		public ForctrlContext(ForloopContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterForctrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitForctrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitForctrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ForloopContext forloop() {
		ForloopContext _localctx = new ForloopContext(_ctx, State);
		EnterRule(_localctx, 28, RULE_forloop);
		try {
			_localctx = new ForctrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 212; Match(GIA);
			State = 213; Match(IDENTIFIER);
			State = 214; Match(APO);
			State = 215; Match(INTEGER);
			State = 216; Match(MEXRI);
			State = 217; Match(INTEGER);
			State = 218; Match(ME_BHMA);
			State = 219; expression(0);
			State = 220; statementlist();
			State = 221; Match(TELOS_EPANALIPSIS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SwitchcontrolContext : ParserRuleContext {
		public SwitchcontrolContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_switchcontrol; } }
	 
		public SwitchcontrolContext() { }
		public virtual void CopyFrom(SwitchcontrolContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class SwitchctrlContext : SwitchcontrolContext {
		public ITerminalNode EPILEKSE() { return GetToken(GLOSSAParser.EPILEKSE, 0); }
		public ITerminalNode IDENTIFIER() { return GetToken(GLOSSAParser.IDENTIFIER, 0); }
		public ITerminalNode TELOS_EPILOGON() { return GetToken(GLOSSAParser.TELOS_EPILOGON, 0); }
		public IReadOnlyList<CasescontrolContext> casescontrol() {
			return GetRuleContexts<CasescontrolContext>();
		}
		public CasescontrolContext casescontrol(int i) {
			return GetRuleContext<CasescontrolContext>(i);
		}
		public IReadOnlyList<OtherwisecontrolContext> otherwisecontrol() {
			return GetRuleContexts<OtherwisecontrolContext>();
		}
		public OtherwisecontrolContext otherwisecontrol(int i) {
			return GetRuleContext<OtherwisecontrolContext>(i);
		}
		public SwitchctrlContext(SwitchcontrolContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterSwitchctrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitSwitchctrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSwitchctrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SwitchcontrolContext switchcontrol() {
		SwitchcontrolContext _localctx = new SwitchcontrolContext(_ctx, State);
		EnterRule(_localctx, 30, RULE_switchcontrol);
		int _la;
		try {
			int _alt;
			_localctx = new SwitchctrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 223; Match(EPILEKSE);
			State = 224; Match(IDENTIFIER);
			State = 226;
			_errHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 225; casescontrol();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 228;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,20,_ctx);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber );
			State = 233;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==PERIPTOSI) {
				{
				{
				State = 230; otherwisecontrol();
				}
				}
				State = 235;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 236; Match(TELOS_EPILOGON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CasescontrolContext : ParserRuleContext {
		public CasescontrolContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_casescontrol; } }
	 
		public CasescontrolContext() { }
		public virtual void CopyFrom(CasescontrolContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class CasectrlContext : CasescontrolContext {
		public ITerminalNode PERIPTOSI() { return GetToken(GLOSSAParser.PERIPTOSI, 0); }
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public CasectrlContext(CasescontrolContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterCasectrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitCasectrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCasectrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CasescontrolContext casescontrol() {
		CasescontrolContext _localctx = new CasescontrolContext(_ctx, State);
		EnterRule(_localctx, 32, RULE_casescontrol);
		try {
			_localctx = new CasectrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 238; Match(PERIPTOSI);
			State = 239; expression(0);
			State = 240; statementlist();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OtherwisecontrolContext : ParserRuleContext {
		public OtherwisecontrolContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_otherwisecontrol; } }
	 
		public OtherwisecontrolContext() { }
		public virtual void CopyFrom(OtherwisecontrolContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class OtherwisectrlContext : OtherwisecontrolContext {
		public ITerminalNode PERIPTOSI() { return GetToken(GLOSSAParser.PERIPTOSI, 0); }
		public ITerminalNode ALLIOS() { return GetToken(GLOSSAParser.ALLIOS, 0); }
		public StatementlistContext statementlist() {
			return GetRuleContext<StatementlistContext>(0);
		}
		public OtherwisectrlContext(OtherwisecontrolContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterOtherwisectrl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitOtherwisectrl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOtherwisectrl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OtherwisecontrolContext otherwisecontrol() {
		OtherwisecontrolContext _localctx = new OtherwisecontrolContext(_ctx, State);
		EnterRule(_localctx, 34, RULE_otherwisecontrol);
		try {
			_localctx = new OtherwisectrlContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 242; Match(PERIPTOSI);
			State = 243; Match(ALLIOS);
			State = 244; statementlist();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionargumentsContext : ParserRuleContext {
		public FunctionargumentsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionarguments; } }
	 
		public FunctionargumentsContext() { }
		public virtual void CopyFrom(FunctionargumentsContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class FunargsContext : FunctionargumentsContext {
		public IReadOnlyList<ITerminalNode> COMMA() { return GetTokens(GLOSSAParser.COMMA); }
		public ITerminalNode IDENTIFIER(int i) {
			return GetToken(GLOSSAParser.IDENTIFIER, i);
		}
		public IReadOnlyList<ITerminalNode> IDENTIFIER() { return GetTokens(GLOSSAParser.IDENTIFIER); }
		public ITerminalNode COMMA(int i) {
			return GetToken(GLOSSAParser.COMMA, i);
		}
		public FunargsContext(FunctionargumentsContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterFunargs(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitFunargs(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunargs(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionargumentsContext functionarguments() {
		FunctionargumentsContext _localctx = new FunctionargumentsContext(_ctx, State);
		EnterRule(_localctx, 36, RULE_functionarguments);
		int _la;
		try {
			_localctx = new FunargsContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 246; Match(IDENTIFIER);
			State = 251;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 247; Match(COMMA);
				State = 248; Match(IDENTIFIER);
				}
				}
				State = 253;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AssignmentContext : ParserRuleContext {
		public AssignmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assignment; } }
	 
		public AssignmentContext() { }
		public virtual void CopyFrom(AssignmentContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class AssignContext : AssignmentContext {
		public ITerminalNode ASSIGNMENT() { return GetToken(GLOSSAParser.ASSIGNMENT, 0); }
		public ITerminalNode IDENTIFIER() { return GetToken(GLOSSAParser.IDENTIFIER, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public AssignContext(AssignmentContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterAssign(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitAssign(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssign(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AssignmentContext assignment() {
		AssignmentContext _localctx = new AssignmentContext(_ctx, State);
		EnterRule(_localctx, 38, RULE_assignment);
		try {
			_localctx = new AssignContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 254; Match(IDENTIFIER);
			State = 255; Match(ASSIGNMENT);
			State = 256; expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
	 
		public ExpressionContext() { }
		public virtual void CopyFrom(ExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Expr_compareContext : ExpressionContext {
		public IToken op;
		public ITerminalNode EQUALS() { return GetToken(GLOSSAParser.EQUALS, 0); }
		public ITerminalNode GE() { return GetToken(GLOSSAParser.GE, 0); }
		public ITerminalNode NOTEQUALS() { return GetToken(GLOSSAParser.NOTEQUALS, 0); }
		public ITerminalNode LT() { return GetToken(GLOSSAParser.LT, 0); }
		public ITerminalNode GT() { return GetToken(GLOSSAParser.GT, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode LE() { return GetToken(GLOSSAParser.LE, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public Expr_compareContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_compare(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_compare(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_compare(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_muldivContext : ExpressionContext {
		public IToken op;
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode DIV() { return GetToken(GLOSSAParser.DIV, 0); }
		public ITerminalNode MUL() { return GetToken(GLOSSAParser.MUL, 0); }
		public Expr_muldivContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_muldiv(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_muldiv(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_muldiv(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_orContext : ExpressionContext {
		public ITerminalNode H() { return GetToken(GLOSSAParser.H, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public Expr_orContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_or(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_or(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_or(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_powerContext : ExpressionContext {
		public ITerminalNode POWER() { return GetToken(GLOSSAParser.POWER, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public Expr_powerContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_power(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_power(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_power(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_andContext : ExpressionContext {
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode KAI() { return GetToken(GLOSSAParser.KAI, 0); }
		public Expr_andContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_and(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_and(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_and(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_parenContext : ExpressionContext {
		public ITerminalNode LPAREN() { return GetToken(GLOSSAParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(GLOSSAParser.RPAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Expr_parenContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_paren(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_paren(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_paren(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_funcproccallContext : ExpressionContext {
		public FunctionargumentsContext functionarguments() {
			return GetRuleContext<FunctionargumentsContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(GLOSSAParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(GLOSSAParser.RPAREN, 0); }
		public ITerminalNode IDENTIFIER() { return GetToken(GLOSSAParser.IDENTIFIER, 0); }
		public Expr_funcproccallContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_funcproccall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_funcproccall(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_funcproccall(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_expressionprimitivesContext : ExpressionContext {
		public ExpressionprimitivesContext expressionprimitives() {
			return GetRuleContext<ExpressionprimitivesContext>(0);
		}
		public Expr_expressionprimitivesContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_expressionprimitives(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_expressionprimitives(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_expressionprimitives(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_unaryContext : ExpressionContext {
		public IToken op;
		public ITerminalNode PLUS() { return GetToken(GLOSSAParser.PLUS, 0); }
		public ITerminalNode MINUS() { return GetToken(GLOSSAParser.MINUS, 0); }
		public ITerminalNode OXI() { return GetToken(GLOSSAParser.OXI, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Expr_unaryContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_unary(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_unary(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_unary(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expr_plusminusContext : ExpressionContext {
		public IToken op;
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode PLUS() { return GetToken(GLOSSAParser.PLUS, 0); }
		public ITerminalNode MINUS() { return GetToken(GLOSSAParser.MINUS, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public Expr_plusminusContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpr_plusminus(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpr_plusminus(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr_plusminus(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		return expression(0);
	}

	private ExpressionContext expression(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		ExpressionContext _localctx = new ExpressionContext(_ctx, _parentState);
		ExpressionContext _prevctx = _localctx;
		int _startState = 40;
		EnterRecursionRule(_localctx, 40, RULE_expression, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 272;
			switch ( Interpreter.AdaptivePredict(_input,24,_ctx) ) {
			case 1:
				{
				_localctx = new Expr_unaryContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;

				State = 259;
				((Expr_unaryContext)_localctx).op = _input.Lt(1);
				_la = _input.La(1);
				if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << OXI) | (1L << PLUS) | (1L << MINUS))) != 0)) ) {
					((Expr_unaryContext)_localctx).op = _errHandler.RecoverInline(this);
				}
				Consume();
				State = 260; expression(8);
				}
				break;

			case 2:
				{
				_localctx = new Expr_parenContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 261; Match(LPAREN);
				State = 262; expression(0);
				State = 263; Match(RPAREN);
				}
				break;

			case 3:
				{
				_localctx = new Expr_funcproccallContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 265; Match(IDENTIFIER);
				State = 266; Match(LPAREN);
				State = 268;
				_la = _input.La(1);
				if (_la==IDENTIFIER) {
					{
					State = 267; functionarguments();
					}
				}

				State = 270; Match(RPAREN);
				}
				break;

			case 4:
				{
				_localctx = new Expr_expressionprimitivesContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 271; expressionprimitives();
				}
				break;
			}
			_ctx.stop = _input.Lt(-1);
			State = 294;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,26,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 292;
					switch ( Interpreter.AdaptivePredict(_input,25,_ctx) ) {
					case 1:
						{
						_localctx = new Expr_powerContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 274;
						if (!(Precpred(_ctx, 9))) throw new FailedPredicateException(this, "Precpred(_ctx, 9)");
						State = 275; Match(POWER);
						State = 276; expression(9);
						}
						break;

					case 2:
						{
						_localctx = new Expr_muldivContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 277;
						if (!(Precpred(_ctx, 7))) throw new FailedPredicateException(this, "Precpred(_ctx, 7)");
						State = 278;
						((Expr_muldivContext)_localctx).op = _input.Lt(1);
						_la = _input.La(1);
						if ( !(_la==MUL || _la==DIV) ) {
							((Expr_muldivContext)_localctx).op = _errHandler.RecoverInline(this);
						}
						Consume();
						State = 279; expression(8);
						}
						break;

					case 3:
						{
						_localctx = new Expr_plusminusContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 280;
						if (!(Precpred(_ctx, 6))) throw new FailedPredicateException(this, "Precpred(_ctx, 6)");
						State = 281;
						((Expr_plusminusContext)_localctx).op = _input.Lt(1);
						_la = _input.La(1);
						if ( !(_la==PLUS || _la==MINUS) ) {
							((Expr_plusminusContext)_localctx).op = _errHandler.RecoverInline(this);
						}
						Consume();
						State = 282; expression(7);
						}
						break;

					case 4:
						{
						_localctx = new Expr_compareContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 283;
						if (!(Precpred(_ctx, 5))) throw new FailedPredicateException(this, "Precpred(_ctx, 5)");
						State = 284;
						((Expr_compareContext)_localctx).op = _input.Lt(1);
						_la = _input.La(1);
						if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << EQUALS) | (1L << NOTEQUALS) | (1L << GT) | (1L << GE) | (1L << LT) | (1L << LE))) != 0)) ) {
							((Expr_compareContext)_localctx).op = _errHandler.RecoverInline(this);
						}
						Consume();
						State = 285; expression(6);
						}
						break;

					case 5:
						{
						_localctx = new Expr_andContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 286;
						if (!(Precpred(_ctx, 4))) throw new FailedPredicateException(this, "Precpred(_ctx, 4)");
						State = 287; Match(KAI);
						State = 288; expression(5);
						}
						break;

					case 6:
						{
						_localctx = new Expr_orContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 289;
						if (!(Precpred(_ctx, 3))) throw new FailedPredicateException(this, "Precpred(_ctx, 3)");
						State = 290; Match(H);
						State = 291; expression(4);
						}
						break;
					}
					} 
				}
				State = 296;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,26,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class ExpressionprimitivesContext : ParserRuleContext {
		public ExpressionprimitivesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionprimitives; } }
	 
		public ExpressionprimitivesContext() { }
		public virtual void CopyFrom(ExpressionprimitivesContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Expressionprimitives_stringContext : ExpressionprimitivesContext {
		public ITerminalNode STRING() { return GetToken(GLOSSAParser.STRING, 0); }
		public Expressionprimitives_stringContext(ExpressionprimitivesContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpressionprimitives_string(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpressionprimitives_string(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionprimitives_string(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expressionprimitives_intContext : ExpressionprimitivesContext {
		public ITerminalNode INTEGER() { return GetToken(GLOSSAParser.INTEGER, 0); }
		public Expressionprimitives_intContext(ExpressionprimitivesContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpressionprimitives_int(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpressionprimitives_int(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionprimitives_int(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expressionprimitives_decContext : ExpressionprimitivesContext {
		public ITerminalNode DECIMAL() { return GetToken(GLOSSAParser.DECIMAL, 0); }
		public Expressionprimitives_decContext(ExpressionprimitivesContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpressionprimitives_dec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpressionprimitives_dec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionprimitives_dec(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Expressionprimitives_identifierContext : ExpressionprimitivesContext {
		public ITerminalNode IDENTIFIER() { return GetToken(GLOSSAParser.IDENTIFIER, 0); }
		public Expressionprimitives_identifierContext(ExpressionprimitivesContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterExpressionprimitives_identifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitExpressionprimitives_identifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionprimitives_identifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionprimitivesContext expressionprimitives() {
		ExpressionprimitivesContext _localctx = new ExpressionprimitivesContext(_ctx, State);
		EnterRule(_localctx, 42, RULE_expressionprimitives);
		try {
			State = 301;
			switch (_input.La(1)) {
			case INTEGER:
				_localctx = new Expressionprimitives_intContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 297; Match(INTEGER);
				}
				break;
			case DECIMAL:
				_localctx = new Expressionprimitives_decContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 298; Match(DECIMAL);
				}
				break;
			case STRING:
				_localctx = new Expressionprimitives_stringContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 299; Match(STRING);
				}
				break;
			case IDENTIFIER:
				_localctx = new Expressionprimitives_identifierContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 300; Match(IDENTIFIER);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeContext : ParserRuleContext {
		public TypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type; } }
	 
		public TypeContext() { }
		public virtual void CopyFrom(TypeContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Type_pragmatikesContext : TypeContext {
		public ITerminalNode PRAGMATIKES() { return GetToken(GLOSSAParser.PRAGMATIKES, 0); }
		public Type_pragmatikesContext(TypeContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterType_pragmatikes(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitType_pragmatikes(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_pragmatikes(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Type_xaraktiresContext : TypeContext {
		public ITerminalNode XARAKTHRES() { return GetToken(GLOSSAParser.XARAKTHRES, 0); }
		public Type_xaraktiresContext(TypeContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterType_xaraktires(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitType_xaraktires(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_xaraktires(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Type_akeraiesContext : TypeContext {
		public ITerminalNode AKERAIES() { return GetToken(GLOSSAParser.AKERAIES, 0); }
		public Type_akeraiesContext(TypeContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterType_akeraies(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitType_akeraies(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_akeraies(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Type_logikesContext : TypeContext {
		public ITerminalNode LOGIKES() { return GetToken(GLOSSAParser.LOGIKES, 0); }
		public Type_logikesContext(TypeContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterType_logikes(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitType_logikes(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_logikes(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeContext type() {
		TypeContext _localctx = new TypeContext(_ctx, State);
		EnterRule(_localctx, 44, RULE_type);
		try {
			State = 307;
			switch (_input.La(1)) {
			case AKERAIES:
				_localctx = new Type_akeraiesContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 303; Match(AKERAIES);
				}
				break;
			case PRAGMATIKES:
				_localctx = new Type_pragmatikesContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 304; Match(PRAGMATIKES);
				}
				break;
			case XARAKTHRES:
				_localctx = new Type_xaraktiresContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 305; Match(XARAKTHRES);
				}
				break;
			case LOGIKES:
				_localctx = new Type_logikesContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 306; Match(LOGIKES);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class KeywordContext : ParserRuleContext {
		public KeywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_keyword; } }
	 
		public KeywordContext() { }
		public virtual void CopyFrom(KeywordContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Keyword_kaleseContext : KeywordContext {
		public ITerminalNode KALESE() { return GetToken(GLOSSAParser.KALESE, 0); }
		public Keyword_kaleseContext(KeywordContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterKeyword_kalese(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitKeyword_kalese(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitKeyword_kalese(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Keyword_diabaseContext : KeywordContext {
		public ITerminalNode DIABASE() { return GetToken(GLOSSAParser.DIABASE, 0); }
		public Keyword_diabaseContext(KeywordContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterKeyword_diabase(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitKeyword_diabase(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitKeyword_diabase(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Keyword_ektiposeContext : KeywordContext {
		public ITerminalNode EKTIPOSE() { return GetToken(GLOSSAParser.EKTIPOSE, 0); }
		public Keyword_ektiposeContext(KeywordContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterKeyword_ektipose(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitKeyword_ektipose(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitKeyword_ektipose(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Keyword_grapseContext : KeywordContext {
		public ITerminalNode GRAPSE() { return GetToken(GLOSSAParser.GRAPSE, 0); }
		public Keyword_grapseContext(KeywordContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterKeyword_grapse(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitKeyword_grapse(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitKeyword_grapse(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public KeywordContext keyword() {
		KeywordContext _localctx = new KeywordContext(_ctx, State);
		EnterRule(_localctx, 46, RULE_keyword);
		try {
			State = 313;
			switch (_input.La(1)) {
			case GRAPSE:
				_localctx = new Keyword_grapseContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 309; Match(GRAPSE);
				}
				break;
			case EKTIPOSE:
				_localctx = new Keyword_ektiposeContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 310; Match(EKTIPOSE);
				}
				break;
			case DIABASE:
				_localctx = new Keyword_diabaseContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 311; Match(DIABASE);
				}
				break;
			case KALESE:
				_localctx = new Keyword_kaleseContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 312; Match(KALESE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BoolContext : ParserRuleContext {
		public BoolContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bool; } }
	 
		public BoolContext() { }
		public virtual void CopyFrom(BoolContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Bool_trueContext : BoolContext {
		public ITerminalNode TRUE() { return GetToken(GLOSSAParser.TRUE, 0); }
		public Bool_trueContext(BoolContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterBool_true(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitBool_true(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBool_true(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Bool_falseContext : BoolContext {
		public ITerminalNode FALSE() { return GetToken(GLOSSAParser.FALSE, 0); }
		public Bool_falseContext(BoolContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.EnterBool_false(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGLOSSAListener typedListener = listener as IGLOSSAListener;
			if (typedListener != null) typedListener.ExitBool_false(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGLOSSAVisitor<TResult> typedVisitor = visitor as IGLOSSAVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBool_false(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BoolContext @bool() {
		BoolContext _localctx = new BoolContext(_ctx, State);
		EnterRule(_localctx, 48, RULE_bool);
		try {
			State = 317;
			switch (_input.La(1)) {
			case TRUE:
				_localctx = new Bool_trueContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 315; Match(TRUE);
				}
				break;
			case FALSE:
				_localctx = new Bool_falseContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 316; Match(FALSE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 20: return expression_sempred((ExpressionContext)_localctx, predIndex);
		}
		return true;
	}
	private bool expression_sempred(ExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(_ctx, 9);

		case 1: return Precpred(_ctx, 7);

		case 2: return Precpred(_ctx, 6);

		case 3: return Precpred(_ctx, 5);

		case 4: return Precpred(_ctx, 4);

		case 5: return Precpred(_ctx, 3);
		}
		return true;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3\x44\x142\x4\x2"+
		"\t\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4"+
		"\t\t\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10"+
		"\t\x10\x4\x11\t\x11\x4\x12\t\x12\x4\x13\t\x13\x4\x14\t\x14\x4\x15\t\x15"+
		"\x4\x16\t\x16\x4\x17\t\x17\x4\x18\t\x18\x4\x19\t\x19\x4\x1A\t\x1A\x3\x2"+
		"\x3\x2\x3\x2\a\x2\x38\n\x2\f\x2\xE\x2;\v\x2\x3\x3\x3\x3\x3\x3\a\x3@\n"+
		"\x3\f\x3\xE\x3\x43\v\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x4\a\x4J\n\x4\f\x4"+
		"\xE\x4M\v\x4\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x5\x5U\n\x5\x3\x5\x5"+
		"\x5X\n\x5\x3\x6\x3\x6\x5\x6\\\n\x6\x3\a\x3\a\x3\a\x3\a\x3\a\x3\a\a\a\x64"+
		"\n\a\f\a\xE\ag\v\a\x3\a\x5\aj\n\a\x3\a\x3\a\x3\a\x3\a\x3\a\x3\a\x3\a\x3"+
		"\a\x3\a\x3\a\x3\a\x3\a\x5\ax\n\a\x3\b\x3\b\x3\b\x3\b\x3\b\x3\b\a\b\x80"+
		"\n\b\f\b\xE\b\x83\v\b\x3\b\x5\b\x86\n\b\x3\b\x3\b\x3\b\x3\b\x3\b\x3\b"+
		"\x3\b\x3\b\x5\b\x90\n\b\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\a\t\x98\n\t\f\t"+
		"\xE\t\x9B\v\t\x3\t\x3\t\x3\t\x3\t\x3\t\x6\t\xA2\n\t\r\t\xE\t\xA3\x5\t"+
		"\xA6\n\t\x3\n\x3\n\x3\n\x3\n\x6\n\xAC\n\n\r\n\xE\n\xAD\x3\v\x3\v\x3\v"+
		"\x3\v\a\v\xB4\n\v\f\v\xE\v\xB7\v\v\x3\v\a\v\xBA\n\v\f\v\xE\v\xBD\v\v\x3"+
		"\v\x5\v\xC0\n\v\x3\v\x3\v\x3\f\x3\f\x3\f\x3\f\x3\f\x3\r\x3\r\x3\r\x3\xE"+
		"\x3\xE\x3\xE\x3\xE\x3\xE\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\x10\x3"+
		"\x10\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x3"+
		"\x11\x3\x11\x3\x11\x6\x11\xE5\n\x11\r\x11\xE\x11\xE6\x3\x11\a\x11\xEA"+
		"\n\x11\f\x11\xE\x11\xED\v\x11\x3\x11\x3\x11\x3\x12\x3\x12\x3\x12\x3\x12"+
		"\x3\x13\x3\x13\x3\x13\x3\x13\x3\x14\x3\x14\x3\x14\a\x14\xFC\n\x14\f\x14"+
		"\xE\x14\xFF\v\x14\x3\x15\x3\x15\x3\x15\x3\x15\x3\x16\x3\x16\x3\x16\x3"+
		"\x16\x3\x16\x3\x16\x3\x16\x3\x16\x3\x16\x3\x16\x5\x16\x10F\n\x16\x3\x16"+
		"\x3\x16\x5\x16\x113\n\x16\x3\x16\x3\x16\x3\x16\x3\x16\x3\x16\x3\x16\x3"+
		"\x16\x3\x16\x3\x16\x3\x16\x3\x16\x3\x16\x3\x16\x3\x16\x3\x16\x3\x16\x3"+
		"\x16\x3\x16\a\x16\x127\n\x16\f\x16\xE\x16\x12A\v\x16\x3\x17\x3\x17\x3"+
		"\x17\x3\x17\x5\x17\x130\n\x17\x3\x18\x3\x18\x3\x18\x3\x18\x5\x18\x136"+
		"\n\x18\x3\x19\x3\x19\x3\x19\x3\x19\x5\x19\x13C\n\x19\x3\x1A\x3\x1A\x5"+
		"\x1A\x140\n\x1A\x3\x1A\x2\x2\x3*\x1B\x2\x2\x4\x2\x6\x2\b\x2\n\x2\f\x2"+
		"\xE\x2\x10\x2\x12\x2\x14\x2\x16\x2\x18\x2\x1A\x2\x1C\x2\x1E\x2 \x2\"\x2"+
		"$\x2&\x2(\x2*\x2,\x2.\x2\x30\x2\x32\x2\x2\x6\x4\x2**\x35\x36\x3\x2\x37"+
		"\x38\x3\x2\x35\x36\x3\x2/\x34\x155\x2\x34\x3\x2\x2\x2\x4<\x3\x2\x2\x2"+
		"\x6K\x3\x2\x2\x2\bW\x3\x2\x2\x2\n[\x3\x2\x2\x2\fw\x3\x2\x2\x2\xE\x8F\x3"+
		"\x2\x2\x2\x10\xA5\x3\x2\x2\x2\x12\xA7\x3\x2\x2\x2\x14\xAF\x3\x2\x2\x2"+
		"\x16\xC3\x3\x2\x2\x2\x18\xC8\x3\x2\x2\x2\x1A\xCB\x3\x2\x2\x2\x1C\xD0\x3"+
		"\x2\x2\x2\x1E\xD6\x3\x2\x2\x2 \xE1\x3\x2\x2\x2\"\xF0\x3\x2\x2\x2$\xF4"+
		"\x3\x2\x2\x2&\xF8\x3\x2\x2\x2(\x100\x3\x2\x2\x2*\x112\x3\x2\x2\x2,\x12F"+
		"\x3\x2\x2\x2.\x135\x3\x2\x2\x2\x30\x13B\x3\x2\x2\x2\x32\x13F\x3\x2\x2"+
		"\x2\x34\x39\x5\x4\x3\x2\x35\x38\x5\f\a\x2\x36\x38\x5\xE\b\x2\x37\x35\x3"+
		"\x2\x2\x2\x37\x36\x3\x2\x2\x2\x38;\x3\x2\x2\x2\x39\x37\x3\x2\x2\x2\x39"+
		":\x3\x2\x2\x2:\x3\x3\x2\x2\x2;\x39\x3\x2\x2\x2<=\a\x4\x2\x2=\x41\a.\x2"+
		"\x2>@\x5\n\x6\x2?>\x3\x2\x2\x2@\x43\x3\x2\x2\x2\x41?\x3\x2\x2\x2\x41\x42"+
		"\x3\x2\x2\x2\x42\x44\x3\x2\x2\x2\x43\x41\x3\x2\x2\x2\x44\x45\a\x5\x2\x2"+
		"\x45\x46\x5\x6\x4\x2\x46G\a\x6\x2\x2G\x5\x3\x2\x2\x2HJ\x5\b\x5\x2IH\x3"+
		"\x2\x2\x2JM\x3\x2\x2\x2KI\x3\x2\x2\x2KL\x3\x2\x2\x2L\a\x3\x2\x2\x2MK\x3"+
		"\x2\x2\x2NX\x5*\x16\x2OX\x5(\x15\x2PQ\x5\x30\x19\x2QT\x5*\x16\x2RS\a;"+
		"\x2\x2SU\x5*\x16\x2TR\x3\x2\x2\x2TU\x3\x2\x2\x2UX\x3\x2\x2\x2VX\x5\x14"+
		"\v\x2WN\x3\x2\x2\x2WO\x3\x2\x2\x2WP\x3\x2\x2\x2WV\x3\x2\x2\x2X\t\x3\x2"+
		"\x2\x2Y\\\x5\x10\t\x2Z\\\x5\x12\n\x2[Y\x3\x2\x2\x2[Z\x3\x2\x2\x2\\\v\x3"+
		"\x2\x2\x2]^\a\a\x2\x2^i\a.\x2\x2_`\a=\x2\x2`\x65\a.\x2\x2\x61\x62\a;\x2"+
		"\x2\x62\x64\a.\x2\x2\x63\x61\x3\x2\x2\x2\x64g\x3\x2\x2\x2\x65\x63\x3\x2"+
		"\x2\x2\x65\x66\x3\x2\x2\x2\x66h\x3\x2\x2\x2g\x65\x3\x2\x2\x2hj\a>\x2\x2"+
		"i_\x3\x2\x2\x2ij\x3\x2\x2\x2jk\x3\x2\x2\x2kl\a\x3\x2\x2lm\x5.\x18\x2m"+
		"n\x5\x6\x4\x2no\a\b\x2\x2ox\x3\x2\x2\x2pq\a\a\x2\x2qr\a.\x2\x2rs\a\x3"+
		"\x2\x2st\x5.\x18\x2tu\x5\x6\x4\x2uv\a\b\x2\x2vx\x3\x2\x2\x2w]\x3\x2\x2"+
		"\x2wp\x3\x2\x2\x2x\r\x3\x2\x2\x2yz\a\t\x2\x2z\x85\a.\x2\x2{|\a=\x2\x2"+
		"|\x81\a.\x2\x2}~\a;\x2\x2~\x80\a.\x2\x2\x7F}\x3\x2\x2\x2\x80\x83\x3\x2"+
		"\x2\x2\x81\x7F\x3\x2\x2\x2\x81\x82\x3\x2\x2\x2\x82\x84\x3\x2\x2\x2\x83"+
		"\x81\x3\x2\x2\x2\x84\x86\a>\x2\x2\x85{\x3\x2\x2\x2\x85\x86\x3\x2\x2\x2"+
		"\x86\x87\x3\x2\x2\x2\x87\x88\x5\x6\x4\x2\x88\x89\a\n\x2\x2\x89\x90\x3"+
		"\x2\x2\x2\x8A\x8B\a\t\x2\x2\x8B\x8C\a.\x2\x2\x8C\x8D\x5\x6\x4\x2\x8D\x8E"+
		"\a\n\x2\x2\x8E\x90\x3\x2\x2\x2\x8Fy\x3\x2\x2\x2\x8F\x8A\x3\x2\x2\x2\x90"+
		"\xF\x3\x2\x2\x2\x91\x92\a\v\x2\x2\x92\x93\x5.\x18\x2\x93\x94\a\x3\x2\x2"+
		"\x94\x99\a.\x2\x2\x95\x96\a;\x2\x2\x96\x98\a.\x2\x2\x97\x95\x3\x2\x2\x2"+
		"\x98\x9B\x3\x2\x2\x2\x99\x97\x3\x2\x2\x2\x99\x9A\x3\x2\x2\x2\x9A\xA6\x3"+
		"\x2\x2\x2\x9B\x99\x3\x2\x2\x2\x9C\xA1\a\v\x2\x2\x9D\x9E\x5.\x18\x2\x9E"+
		"\x9F\a\x3\x2\x2\x9F\xA0\a.\x2\x2\xA0\xA2\x3\x2\x2\x2\xA1\x9D\x3\x2\x2"+
		"\x2\xA2\xA3\x3\x2\x2\x2\xA3\xA1\x3\x2\x2\x2\xA3\xA4\x3\x2\x2\x2\xA4\xA6"+
		"\x3\x2\x2\x2\xA5\x91\x3\x2\x2\x2\xA5\x9C\x3\x2\x2\x2\xA6\x11\x3\x2\x2"+
		"\x2\xA7\xAB\a\f\x2\x2\xA8\xA9\a.\x2\x2\xA9\xAA\a/\x2\x2\xAA\xAC\x5,\x17"+
		"\x2\xAB\xA8\x3\x2\x2\x2\xAC\xAD\x3\x2\x2\x2\xAD\xAB\x3\x2\x2\x2\xAD\xAE"+
		"\x3\x2\x2\x2\xAE\x13\x3\x2\x2\x2\xAF\xB0\a\r\x2\x2\xB0\xB1\x5*\x16\x2"+
		"\xB1\xB5\a\xE\x2\x2\xB2\xB4\x5\b\x5\x2\xB3\xB2\x3\x2\x2\x2\xB4\xB7\x3"+
		"\x2\x2\x2\xB5\xB3\x3\x2\x2\x2\xB5\xB6\x3\x2\x2\x2\xB6\xBB\x3\x2\x2\x2"+
		"\xB7\xB5\x3\x2\x2\x2\xB8\xBA\x5\x16\f\x2\xB9\xB8\x3\x2\x2\x2\xBA\xBD\x3"+
		"\x2\x2\x2\xBB\xB9\x3\x2\x2\x2\xBB\xBC\x3\x2\x2\x2\xBC\xBF\x3\x2\x2\x2"+
		"\xBD\xBB\x3\x2\x2\x2\xBE\xC0\x5\x18\r\x2\xBF\xBE\x3\x2\x2\x2\xBF\xC0\x3"+
		"\x2\x2\x2\xC0\xC1\x3\x2\x2\x2\xC1\xC2\a\xF\x2\x2\xC2\x15\x3\x2\x2\x2\xC3"+
		"\xC4\a\x10\x2\x2\xC4\xC5\x5*\x16\x2\xC5\xC6\a\xE\x2\x2\xC6\xC7\x5\x6\x4"+
		"\x2\xC7\x17\x3\x2\x2\x2\xC8\xC9\a\x11\x2\x2\xC9\xCA\x5\x6\x4\x2\xCA\x19"+
		"\x3\x2\x2\x2\xCB\xCC\a\x12\x2\x2\xCC\xCD\x5\x6\x4\x2\xCD\xCE\a\x13\x2"+
		"\x2\xCE\xCF\x5*\x16\x2\xCF\x1B\x3\x2\x2\x2\xD0\xD1\a\x14\x2\x2\xD1\xD2"+
		"\x5*\x16\x2\xD2\xD3\a\x15\x2\x2\xD3\xD4\x5\x6\x4\x2\xD4\xD5\a\x16\x2\x2"+
		"\xD5\x1D\x3\x2\x2\x2\xD6\xD7\a\x17\x2\x2\xD7\xD8\a.\x2\x2\xD8\xD9\a\x18"+
		"\x2\x2\xD9\xDA\a+\x2\x2\xDA\xDB\a\x19\x2\x2\xDB\xDC\a+\x2\x2\xDC\xDD\a"+
		"\x1A\x2\x2\xDD\xDE\x5*\x16\x2\xDE\xDF\x5\x6\x4\x2\xDF\xE0\a\x16\x2\x2"+
		"\xE0\x1F\x3\x2\x2\x2\xE1\xE2\a\x1B\x2\x2\xE2\xE4\a.\x2\x2\xE3\xE5\x5\""+
		"\x12\x2\xE4\xE3\x3\x2\x2\x2\xE5\xE6\x3\x2\x2\x2\xE6\xE4\x3\x2\x2\x2\xE6"+
		"\xE7\x3\x2\x2\x2\xE7\xEB\x3\x2\x2\x2\xE8\xEA\x5$\x13\x2\xE9\xE8\x3\x2"+
		"\x2\x2\xEA\xED\x3\x2\x2\x2\xEB\xE9\x3\x2\x2\x2\xEB\xEC\x3\x2\x2\x2\xEC"+
		"\xEE\x3\x2\x2\x2\xED\xEB\x3\x2\x2\x2\xEE\xEF\a\x1D\x2\x2\xEF!\x3\x2\x2"+
		"\x2\xF0\xF1\a\x1C\x2\x2\xF1\xF2\x5*\x16\x2\xF2\xF3\x5\x6\x4\x2\xF3#\x3"+
		"\x2\x2\x2\xF4\xF5\a\x1C\x2\x2\xF5\xF6\a\x11\x2\x2\xF6\xF7\x5\x6\x4\x2"+
		"\xF7%\x3\x2\x2\x2\xF8\xFD\a.\x2\x2\xF9\xFA\a;\x2\x2\xFA\xFC\a.\x2\x2\xFB"+
		"\xF9\x3\x2\x2\x2\xFC\xFF\x3\x2\x2\x2\xFD\xFB\x3\x2\x2\x2\xFD\xFE\x3\x2"+
		"\x2\x2\xFE\'\x3\x2\x2\x2\xFF\xFD\x3\x2\x2\x2\x100\x101\a.\x2\x2\x101\x102"+
		"\a<\x2\x2\x102\x103\x5*\x16\x2\x103)\x3\x2\x2\x2\x104\x105\b\x16\x1\x2"+
		"\x105\x106\t\x2\x2\x2\x106\x113\x5*\x16\n\x107\x108\a=\x2\x2\x108\x109"+
		"\x5*\x16\x2\x109\x10A\a>\x2\x2\x10A\x113\x3\x2\x2\x2\x10B\x10C\a.\x2\x2"+
		"\x10C\x10E\a=\x2\x2\x10D\x10F\x5&\x14\x2\x10E\x10D\x3\x2\x2\x2\x10E\x10F"+
		"\x3\x2\x2\x2\x10F\x110\x3\x2\x2\x2\x110\x113\a>\x2\x2\x111\x113\x5,\x17"+
		"\x2\x112\x104\x3\x2\x2\x2\x112\x107\x3\x2\x2\x2\x112\x10B\x3\x2\x2\x2"+
		"\x112\x111\x3\x2\x2\x2\x113\x128\x3\x2\x2\x2\x114\x115\f\v\x2\x2\x115"+
		"\x116\a\x39\x2\x2\x116\x127\x5*\x16\v\x117\x118\f\t\x2\x2\x118\x119\t"+
		"\x3\x2\x2\x119\x127\x5*\x16\n\x11A\x11B\f\b\x2\x2\x11B\x11C\t\x4\x2\x2"+
		"\x11C\x127\x5*\x16\t\x11D\x11E\f\a\x2\x2\x11E\x11F\t\x5\x2\x2\x11F\x127"+
		"\x5*\x16\b\x120\x121\f\x6\x2\x2\x121\x122\a(\x2\x2\x122\x127\x5*\x16\a"+
		"\x123\x124\f\x5\x2\x2\x124\x125\a)\x2\x2\x125\x127\x5*\x16\x6\x126\x114"+
		"\x3\x2\x2\x2\x126\x117\x3\x2\x2\x2\x126\x11A\x3\x2\x2\x2\x126\x11D\x3"+
		"\x2\x2\x2\x126\x120\x3\x2\x2\x2\x126\x123\x3\x2\x2\x2\x127\x12A\x3\x2"+
		"\x2\x2\x128\x126\x3\x2\x2\x2\x128\x129\x3\x2\x2\x2\x129+\x3\x2\x2\x2\x12A"+
		"\x128\x3\x2\x2\x2\x12B\x130\a+\x2\x2\x12C\x130\a,\x2\x2\x12D\x130\a-\x2"+
		"\x2\x12E\x130\a.\x2\x2\x12F\x12B\x3\x2\x2\x2\x12F\x12C\x3\x2\x2\x2\x12F"+
		"\x12D\x3\x2\x2\x2\x12F\x12E\x3\x2\x2\x2\x130-\x3\x2\x2\x2\x131\x136\a"+
		"\x1E\x2\x2\x132\x136\a\x1F\x2\x2\x133\x136\a \x2\x2\x134\x136\a!\x2\x2"+
		"\x135\x131\x3\x2\x2\x2\x135\x132\x3\x2\x2\x2\x135\x133\x3\x2\x2\x2\x135"+
		"\x134\x3\x2\x2\x2\x136/\x3\x2\x2\x2\x137\x13C\a\"\x2\x2\x138\x13C\a#\x2"+
		"\x2\x139\x13C\a$\x2\x2\x13A\x13C\a%\x2\x2\x13B\x137\x3\x2\x2\x2\x13B\x138"+
		"\x3\x2\x2\x2\x13B\x139\x3\x2\x2\x2\x13B\x13A\x3\x2\x2\x2\x13C\x31\x3\x2"+
		"\x2\x2\x13D\x140\a&\x2\x2\x13E\x140\a\'\x2\x2\x13F\x13D\x3\x2\x2\x2\x13F"+
		"\x13E\x3\x2\x2\x2\x140\x33\x3\x2\x2\x2!\x37\x39\x41KTW[\x65iw\x81\x85"+
		"\x8F\x99\xA3\xA5\xAD\xB5\xBB\xBF\xE6\xEB\xFD\x10E\x112\x126\x128\x12F"+
		"\x135\x13B\x13F";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace Glossa
